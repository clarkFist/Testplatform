/******************************************************************************
 * COPYRIGHT (C) Alstom Transport 2008. STEP Project. All rights reserved.
 *****************************************************************************/

/******************** FILE HEADER *******************************************/
/**\addtogroup MSTEP_MODULE
 * \{*/
/**\addtogroup MSTEP_INTERFACE
 * \{*/
/**
 ******************************************************************************
 * \if API
 * \mainpage MSTEP API
 *
 * \section Description
 * This document describes the MSTEP API provided to the guest application by
 * MSTEP kernel software layer.\n
 * \note This software will be available and operational only to guest board
 *       connected to internal bus (CAN).
 *
 * The following sections describe functionalities provided.\n
 *
 * \section Features are:
 * - Plateform integration:
 *   -# Software customization:
 *      - \ref Custom
 *      - \ref FeatureUserPlug
 *   -# \ref FeatureHw
 *   -# \ref FeatureKey
 * - Software functionalities:
 *   -# \ref FeatureIODB
 *   -# \ref FeatureKernel2oo2
 *   -# \ref FeatureNVMEM
 *   -# \ref FeatureTime
 *   -# \ref FeatureDCA
 *   -# \ref FeatureMaintenance
 *   -# \ref FeatureUDP
 *   -# \ref FeatureFuses
 * - Tools functions:
 *   -# \ref FeatureCRYPTLIB
 *   -# \ref DebugItf
 *   -# \ref OthersFeatures
 *      - Standard C functions (limited)
 *      - Temporisation and OS object access
 *      - Fault management
 *      - Max CPU usage
 *      - Reprog activation
 *      - Global data identification
 *
 * \section integration Platform integration
 * \section software Software functionalities
 * \section tools Tools functions
 *
 * \subsection FeatureKernel2oo2 Kernel2oo2
 * This module provides functions to ensure communication between CPU to make
 * a 2oo2 kernel.
 *
 * Provided features are
 * - Beginning of cycle synchronization in 2oo2, cycleId built in safety with
 *   remote CPU.\n
 * - Vote cycle data in safety with remote CPU.\n
 * - CpuSend/CpuWait: Send/wait data to/from distant CPU.\n
 * - CpuExchange: exchange data with distant CPU.\n
 *
 * \note
 *       -# Inter-CPU communication support fragmentation.
 *       -# The send and receive support post before wait. Start of data
 *         transmission on the link does not need that the receiving task is
 *         waiting.
 *       -# The cycleId is a 32 bits data, generated by pseudo-random LFSR
 *         algorithm.
 *
 * \par Cycle description
 * A cycle shall begin by the call to the function
 * \ref MSTEP_F_K2oo2CycleBegin. This function generate a cycleId used during
 * the whole cycle.\n
 * Once previous call done, the main process could began. The treatment in
 * this part are not related to MSTEP kernel software. If guest application
 * got to exchange data with distant CPU, the function
 * \ref MSTEP_F_K2oo2CpuSendExt and \ref MSTEP_F_K2oo2CpuWaitExt shall be used. These
 * function works by peer. A Send from the CPU_A shall be waited on CPU_B.\n
 * In order to simplify send and wait management, an exchange function can be
 * used.\n
 * The task cycle is ended by calling \ref MSTEP_F_K2oo2CycleEndExt that performs
 * 2oo2 controls of the result built during the cycle. Consistency error
 * between CPU leads to a software fuse.
 *
 * \note Using cycle is not mandatory for 2oo2 exchange if freshness check
 *       is not requested.
 *
 * Following drawing shows exchange process between CPU and function call
 * order.\n
 * \image latex K2oo2.jpg
 *
 * \par Performances
 *      Measurement have been performed in order to qualify the link. See memo
 *      <b>STEP_SW_TRV1348000142_K2oo2_Benchmark.doc</b> for performance
 *      details.
 *
 * \par Limitations
 * - The MTU (maximum transfer unit) is 200 bytes, else fragmentation will
 *    be applied by \ref MSTEP_F_K2oo2CpuSendExt.\n
 * - Time out on message wait is (15ms * nbFragment) milliseconds. Time out
 *   elapse on MSTEP_F_K2oo2CpuWaitExt() leads to a software fuse \n
 * \note User shall be aware of the payload to ensure correct functioning.
 *       Each application shall perform an analysis to determine the maximum
 *       size and fragmentation of messages.\n
 *
 * \subsection FeatureCRYPTLIB Cryptographic
 * This functions compute cryptographic result:
 * - Checksum CRC-16 see \ref MSTEP_F_CryptlibCRC16CCITTCompute for precise
 *   definition of CRC used.
 * - Checksum CRC-32 see \ref MSTEP_F_CryptlibCRC32CCITTCompute for precise
 *   definition of CRCs used.
 * - Checksum CRC-32 channel 1 FSFB2 see
 *   \ref MSTEP_F_CryptlibCRC32FSFB2ChanOneCompute for precise definition of
 *   CRC used.
 * - Cypher using DES (Data Encryption Standard) algorithm on a defined buffer.
 *   Applied standard is FIPS PUB 46. \ref MSTEP_F_CryptlibDESCompute
 * - Scramble a 32 bits key by part of 16 bits
 *
 * \subsection FeatureUserPlug User tasks
 * MSTEP kernel provides the possibility to user to have up to ten cyclic tasks
 * for its own processing. The interface is based on a hook mechanism.
 * User shall provide to configuration function the following hooks for each
 * task to be scheduled by the OS:
 * - F_Create: Allocate and initialize all hardware and software static
 *             resources, such as message queue and semaphore.
 * - F_Configure: Configure the guest application, build its own data from the
 *                key data. This function is called after the decision to go
 *                in BOOT_FAILED mode or not. Checking of the key validity shall
 *                be done in GUEST_F_ConfigSubAreaCheck hook.
 *                Note: Divergence of both CPU introduced by F_Configure hook is
 *                checked at end of F_Start a special care shall be taken at
 *                synchronizing execution.
 * - F_Start: Start external hardware processing.
 *            Note: At return of all application F_Configure and F_Start hooks
 *            Kernel checks the divergence of both CPU, it has to be less than
 *            2 seconds strictly.
 * - F_Body(TaskLoopMode): Main processing of the user, called
 *                         periodically.
 *   The parameter TaskLoopMode given in argument is used by the
 *   main loop to provide two functional mode for the main loop. A restrictive
 *   one and a normal one, depending the software operational mode.
 *   It is important to remember that, before the "F_Create" function is called, the
 *   following GUEST hooks are called, by the MSTEP Kernel software, in the following
 *   order:
 *   - GUEST_F_IoSetupGet
 *   - GUEST_F_SystemSetup
 *   - GUEST_F_AllocateMemorySpaceForKernel
 *
 * \par Task configuration
 * In order to configure the task, the following information shall be provided
 * in the MSTEPINC_T_TaskInfo structure.
 *
 * \note
 * -# Minimal period of a cyclic task is 50ms. Step of increment of the
 *    period is 50ms. If the task is non-cyclic, taskPeriod parameters
 *    shall be set to 0 in order to make the task normally scheduled by OS.
 *    In that case, no delay is involved by the kernel software, it is up to
 *    the guest tasks to provide delay to avoid cpu overload.
 * -# Maximal period of a cyclic task is 1 minutes (60000 ms).
 * -# Maximal software watchdog period is 65535 ms.
 * -# taskId is the identifier of the guest task. It must be uniq.
 * -# prioLevel is the priority level of the task. There are two priority levels:
 *    MSTEPINC_C_TASK_PRIOLEVEL_HIGH and MSTEPINC_C_TASK_PRIOLEVEL_LOW.
 *    Tasks with priority level MSTEPINC_C_TASK_PRIOLEVEL_LOW have a priority
 *    lower than kernel tasks but have highest priority than
 *    the built-in self-test, Stat and Idle tasks.
 *    Tasks with priority level MSTEPINC_C_TASK_PRIOLEVEL_HIGH have a priority
 *    higher than kernel tasks which manage A Interface
 * -# taskPrio is the priority of the guest tasks among all guest task in the same
 *    priority level. In a same priority level every taskPrio must be unique
 *    consecutive and start from 0.
 * -# taskStartOrder is guest task start order. Each taskStartOrder must
 *    be unique consecutive and start from 0.
 * -# cpuTask tell on which CPU the task is executed. Its value can be
 *    MSTEPINC_C_RUN_TASK_ON_CPU_A, MSTEPINC_C_RUN_TASK_ON_CPU_B, or
 *    MSTEPINC_C_RUN_TASK_ON_BOTH_CPU
 * -# Purpose of the software watchdog is to ensure that the task is
 *    executed periodically and pass through specific check point. It shall
 *    be called once in the main task loop of each body. It shall be called
 *    once in the main task loop. Interface to the software watchdog is
 *    \ref MSTEP_F_TaskFlagSet.
 * -# OS object creation functions and memory block definition shall only be
 *    called during F_Create execution.\n
 * -# All tasks shall be operational (kernel and application) after a maximum of 30 minutes.
 *    This means that F_Create, F_Configure, F_Start hooks of all tasks (including kernel ones)
 *    the cumulative sum shall have be less than this 30 minutes.
 *
 * Following scheme represent the process of task configuration.\n
 * \image latex task.jpg
 *
 * \subsection FeatureIODB Safety Input/Output database
 * Safety Input Output Database provide the following features:
 * - Provide read/write data access of local database from Application: read
 *  (MSTEP_F_IodbRequest) and write (MSTEP_F_IodbSubmit).
 * - Database is updated depending on dataId configuration.
 * - Conversion between dataId into PDO is managed into the MSTEP kernel.
 * - Database content auto-check are performed in 2oo2 every 50ms.
 * - Database update is performed in 2oo2 every 50ms, delta introduced by 2oo2
 *   processing of application is managed.
 * - Database content is updated by internal bus and content sent on internal
 *   bus as configured in key.
 * - Data content transfered over CAN is safety protected.
 * - (Optional if activated) the IODB is updated by InterfaceA frame received
 *   and validated in 2oo2.
 *
 * \note Read and write access into IODB shall be done by both CPU. Access
 *       request to IODB will trigger 2oo2 exchange which must be satisfied
 *       at least at the next IODB cycle (50ms). Otherwise a software fuse will
 *       be triggered.
 *
 * \note The maximum size of one data to be written into the database is 32
 *       bits. The size of data accessed into the database are tied to the
 *       configuration values referring to the data identifier.
 *
 * \note Bit ordering of data in the database is LSB.
 *
 * \par Limitations
 * -# Two tasks shall not write the same dataId during the  same cycle.
 *    Consitstancy is not guarantee by MSTEP kernel if this case occurs.
 * -# Read and write Access to the database shall only be done once by task
 *    cycle. I.e. At least one read and one write by task cycle each 100ms.
 * -# No more than four tasks shall read and write into the database.
 * -# Write access shall be grouped.
 * -# \ref MSTEP_F_IodbSubmit function shall be called on both CPU in the same
 *    logic cycle. The data written will be checked in 2oo2 during next CAN
 *    cycle. If the data are different a SW_FUSE is triggered. If the data
 *    are only present on one CPU, this is a normal case due to 2oo2 architecture
 *    (both processor could be only synchronized logically), but at next cycle
 *    the data shall be present or this is a critical issue.
 * -# \ref MSTEP_F_IodbRequest function ensures that both processor retrieve the
 *    data from the same IODB cycle. A call on both CPU shall be done. This
 *    function shall be called only once between an MSTEP_F_K2oo2CycleBegin()
 *    and MSTEP_F_K2oo2CycleEndExt().
 *
 * \par Key configures:
 * - Database content read from internal network,
 * - Database content sent to the internal network.
 * - The mapping of application data to internal bus frame PDOs is defined by
 *   key parameters. Data conversion between guest application and database
 *   is performed by the kernel.
 *
 * \note Data content consistency is only guaranteed if mapped on a single
 *       PDO (32 bits).
 *
 * \note Mapping of application data to PDOs is defined by key parameters.
 *       Configuration of PDO mapping:
 *       - 4x32 bits of data transfer per module.
 *       - 1 module PDO tx
 *       - n module PDO rx
 *
 * \subsection FeatureNVMEM Non volatile memory
 * Provide storage for 2048 bytes of data into non volatile memory. The
 * functionality provided are:
 * - Provide function to access to data stored in flash memory (read and write).
 * - Copy periodically user data into persistent storage. Periodical back-up is
 *   done in background every 3 hours and last a consequent time. The back-up
 *   use 2 sectors in order to be able to restore data even if the last back-up
 *   failed.
 * - Data are restored at each boot from the last sector saved using a counter. The
 *   sector which have the highest counter is restored. Counter of each sector is
 *   protected by a crc.
 * - Flush functionality is available to force back-up, for example in case of
 *   reboot or failure.
 * - In case of power lost during periodical write the data may be corrupted. In
 *   this case, the other PDA sector will be restored.
 * - The storage is a <b>non safety</b> persistent storage. However it provides
 *   an optional  "safety freshness" features which ensure that old data are not
 *   returned if the latest sector is corrupted.
 * \note NVMEM feature is not provided in 2oo2. It is up to the user to ensure
 * a vote if this is needed.
 * \note NVMEM feature is not linked to GDF and event log. For GDF and event log,
 * there is no flush mechanism available. Write are performed directly.
 *
 * \note Data to be stored shall have a size lesser or equal to 2048 bytes
 *
 * \subsection FeatureTime Time
 * Provide the evolution of the time received on internal bus. This is the same
 * for all CPU connected to the bus.
 *
 * \note The time format is CANOpen: Format used is the data type TIME_OF_DAY
 *        defined in the CANOpen DS301 document. \ref MSTEP_F_TimeGet.
 *
 * \subsection FeatureKey Key parameters
 * - Provide access to Guest application configuration sub-area parameters. Details on key content
 *   can be found in the corresponding SyAD.
 * \note Guest application configuration data are protected against modification during the
 *       whole software execution time.
 *
 * Data provided have their consistency checked before made accessible by the guest
 * application.
 *
 * - Provide access to to Guest parameters.
 * \note Guest parameters are not checked against modification.
 *
 * If guest software application uses modified values of its parameters to perform
 * treatment, it up to the developers of the guest application to prevent the
 * corruption of its data by using the DCA feature.
 *
 * Access to configuration data and parameters is made through a pointer on a memory area
 * covered by periodic kernel self test. If any corruption occurs, the kernel
 * will set the software into safe state. \see MSTEP_F_ConfigGuestSubAreaGet()
 *
 * Provide access to the position of the board in the equipment.
 * \see MSTEP_F_ConfigBoardPositionGet()
 *
 * \subsection FeatureDCA Data constant area
 * DCA service is providing a simple way to store data in a protected memory
 * zone. DCA memory section is locked after all tasks are started, and area
 * consistency is then periodically checked so as to ensure that no change or
 * corruption happened. Putting variables into DCA section is done by using
 * PRAGMA_PLACE_DCA_IDATA and PRAGMA_PLACE_DCA_UDATA macros. First one has to
 * be used for initialized data and second one for uninitialized data.
 *
 * \note DCA data shall not be updated after Task_Start() function hook is called.
 *
 * \subsection FeatureHw Hardware access
 * Guest application shall access to low layer hardware feature. The MSTEP
 * kernel provide access to:
 * - Pin: Configure edge port pin (In/Out).
 * - GPIO: Set and get general purpose Input Output pins
 * - External device: Configure the chip select dedicated for one external
 *   memory device (FPGA will be seen as ram access).
 * - Access up to Two SPI device (only one for STEPPER board). No protocol is
 *   provided.
 * - CPU Id: indicates whether the application runs on CPU A or CPU B.
 * - ISR: Configurable level 1 ISR which have mid-point priority. This IT could
 *   be enabled and disabled.
 *
 * \attention SPI access is not a SIL4 function so it shall not be used for
 *            safety purpose. Execution of SPI access could be delayed.
 *
 * \subsection FeatureMaintenance Maintenance dictionary
 * Provide kernel access to local maintenance dictionary which will be
 * periodically polled by STEPPER module of the rack.\n
 *
 * Configuration of the maintenance dictionary give access up to
 * \ref MSTEPINC_C_MAINTENANCE_ENTRY_COUNT 32 bits long data,
 * both identified by a \ref MSTEPINC_C_MAINTENANCE_ENTRY_NAME_SIZE
 * characters description string.
 *
 * MSTEP Kernel also provide the capability to set 64 failures code into
 * associated to 15 characters context and date of fault appearance.
 *
 * \note Fault appearance date is set by Kernel software.
 *
 * \subsection FeatureUDP UDP Socket
 * Give access to UDP socket.
 * Functions provided are :
 * - MSTEP_F_UDPOpen : Open an UDP socket
 * - MSTEP_F_UDPSend : Send data through an UDP socket
 * - MSTEP_F_UDPRecv : Receive data from a socket
 * - MSTEP_F_UDPClose : Close an UDP socket
 *
 * \subsection FeatureFuses Guest safety flags
 * Give access to safety flags reserved to guest usage.
 * Functions provided are :
 * - MSTEP_F_SafetyFlagBreak : Break a specified safety flag. The guest can choose to be
 *   notified when the broken safety flag is written in FLASH memory.\n
 * - MSTEP_F_SafetyFlagChkWdGet : Get the compensated safety flag value from RAM.
 *
 * \subsection DebugItf Debug interface
 * This function provide debug information.
 * - Text trace through serial port for each CPU on the UART of the
 *   board (if available). Trace could have two behavior depending on the
 *   function used:\n
 *   - Buffered: Tracing only on CPU_A using a task. CPU_B trace on CPU_A UART
 *               inter-CPU link. In that case; the risk of message lost exist
 *               but there is a low impact on scheduling.\n
 *   - Direct: Trace direct using each CPU UART. High impact on scheduling. Use
 *             of this function shall not be done for normal tracing.\n
 * - Guest defined hook called when trace is called. Time spend in this hook
 *   shall be limited to ensure that the scheduling is not perturbed and to
 *   avoid a sanction from the software watchdog.
 * - Guest defined hook called by the MSTEP kernel software on GDF_F_Fault
 *   software fuse triggering. Functionality of this hook shall be limited to
 *   the minimum, as when called, the hardware watchdog is not refreshed.
 *
 * \subsection Custom Software Customization
 * Software customization means the activation or not of some software features
 * (InterfaceA). Software customization is done by calling a GUEST defined
 * function during software initialization that ensure the start of the feature
 * needed.\n
 * Customization provided are:
 * - Guest_No_Ethernet  : Board not connected to Ethernet.\n
 * - Guest_A_Interface  : Board connected to Ethernet though A-interface.\n
 * - Stepper            : CAN master board with redundancy capability, in
 *                        charge of configuration read and dispatch. Connected
 *                        to UEVOL network through A-Interface. Performing
 *                        maintenance request on internal network and answering
 *                        SNMP request from Ethernet network.
 *
 * \section OthersFeatures Features directly provided from other include files
 *  - OSW:   provide functions to create and use OS objects such as semaphore,
 *           FIFO or memory block. This module also provide temporisation
 *           functions.\n
 *           See os_w.h module API - TRV1348000150 for details.
 *  - STD:   provide C standard functions and useful things.\n
 *           See std.h module API - TRV1348000151 for details.
 *  - GDF:   provide functions to check parameters or to take safety or logging
 *           action.\n
 *           See gdf.h module API - TRV1348000147 for details.
 *  - DTXT:  Provide UART tracing on terminal for each CPU.\n
 *           See dtxt.h module API - TRV1348000167 for details.
 *  - GUEST: provide hook template and base configuration function for the
 *           kernel.\n
 *           see step_guest.h module API - TRV1348000148 for details.
 *  - MSTEP_F_GetSoftwareDataID: Get the XOR of each reference CRC
 *
 * \section V_Global Global variables of the module
 *  - MSTEP_V_pIsrFuncGuest: Global symbol used to link guest interrupt handler.
 *      - Protection: No protection needed: all access are atomic (this is a pointer), and there
 *        is no read-modify-write access.
 *  - MSTEP_C_CONFIGKernelTaskInfo: Function pointers and parameters for the kernel task to run
 *      - Protection: No protection needed: Only used by main task at board initialization and defined as const.
 *  - MSTEP_C_CONFIGNbKernelTask: Definition of the number of kernel tasks running in the software
 *      - Protection: No protection needed: Only used by main task at board initialization and defined as const.
 *
 * \section lim Limitations
 * - Debug interface: TFTP will be provided in further release. This interface
 *                    will allow to read memory address.
 *
 * \endif
 *****************************************************************************/
/**\}*/
/**\}*/

#ifndef MSTEP_H
#define MSTEP_H

#include "step_includes.h"

/**\addtogroup MSTEP_INTERFACE
 * \{*/
/******************************************************************************
 * CONSTANTS OF MODULE
 *****************************************************************************/

/** Number of users task. */
#define MSTEP_C_MAX_USER_TASK 10u /**<10 tasks are available for the guest
* application */

/** Determine the size of a task name  */
#define MSTEP_C_TASK_NAME_SIZE 32u /**<Each task name shall have up to 32
* characters */

/** Definition of the maximum payload available on Ethernet */
#define MSTEP_C_MAX_ETH_PAYLOAD 1500u

/** Definition of the size in bytes of the MAC address */
#define MSTEP_C_ETH_MAC_SIZE 6u

/** Number of vitalstamp elements given via MSTEP_F_K2oo2CycleEndExt() */
#define MSTEP_C_VITALSTAMP_SIZE 2u

/** Maximum number of guest TFTP service. */
#define MSTEP_C_TFTP_MAX_GUEST_TFTP_SERVICE     4u

/** Maximum number of possible guest PDA reservation */
#define MSTEP_C_PDA_MAX_RESERVATION             20u

/** Maximum number of possible guest PDA reservation */
#define MSTEP_C_PDA_MAX_TOTAL_SIZE              0x800u

/* CR_Reference 2610 - Correction of define header size */
/** Size in byte of the parameter header for a sector, value to use to go to user data */
#define MSTEP_C_PARAMETER_SECTOR_HEADER_SIZE    22u

/* CR_Reference 1669: SW: Keep track of 2oo2 exchanges for debug assist */
/* K2OO2 function IDs. An ENUM was not used here because there are other IDs present in the k2oo2.h file. */
#define MSTEP_C_FUNCTION_ID_K2OO2_CYCLE_END     101u /**< Id of the K2oo2CycleEnd function */
#define MSTEP_C_FUNCTION_ID_K2OO2_CPU_EXCHANGE  102u /**< Id of the K2oo2CpuExchange function */
#define MSTEP_C_FUNCTION_ID_K2OO2_CPU_SEND      103u /**< Id of the K2oo2CpuSend function */
#define MSTEP_C_FUNCTION_ID_K2OO2_CPU_WAIT      104u /**< Id of the K2oo2CpuWait function */

/******************************************************************************
 * MACROS DEFINITION
 *****************************************************************************/
/* "Macro names contain lower case, in order to maintain the existing API. This does not have any impact in safety or maintainability." */

/* "Macro names do not contain _M_, in order to maintain the existing API. This does not have any impact in safety or maintainability." */

/* "Macro used to keep the caller's line number." */

/* CR_Reference 1669: SW: Keep track of 2oo2 exchanges for debug assist */
/** \see MSTEP_F_K2oo2CycleEndExt */
#define MSTEP_F_K2oo2CycleEnd(pVitalStamp) (MSTEP_F_K2oo2CycleEndExt((const MSTEP_T_VitalStamp* const)(pVitalStamp), (INT8U)(MSTEP_C_FUNCTION_ID_K2OO2_CYCLE_END), (INT16U)(__LINE__)))
/** \see MSTEP_F_K2oo2CpuExchangeExt */
#define MSTEP_F_K2oo2CpuExchange(pBufIn, pBufOut, size, timeout) (MSTEP_F_K2oo2CpuExchangeExt((INT8U* const)(pBufIn), (const INT8U*)(pBufOut), (const INT32U)(size), (const INT16U)(timeout), (INT8U)(MSTEP_C_FUNCTION_ID_K2OO2_CPU_EXCHANGE), (INT16U)(__LINE__)))
/** \see MSTEP_F_K2oo2CpuSendExt */
#define MSTEP_F_K2oo2CpuSend(pBuf, size, timeout) (MSTEP_F_K2oo2CpuSendExt((const INT8U* const)(pBuf), (const INT32U)(size), (const INT16U)(timeout), (INT8U)(MSTEP_C_FUNCTION_ID_K2OO2_CPU_SEND), (INT16U)(__LINE__)))
/** \see MSTEP_F_K2oo2CpuWaitExt */
#define MSTEP_F_K2oo2CpuWait(pBuf, size, timeout) (MSTEP_F_K2oo2CpuWaitExt((INT8U* const)(pBuf), (const INT32U)(size), (const INT16U)(timeout), (INT8U)(MSTEP_C_FUNCTION_ID_K2OO2_CPU_WAIT), (INT16U)(__LINE__)))

/** get statistic storage state: enabled or not */
/* "Simple accessor to a structure field" */
#define MSTEP_M_STATISTIC_STATE(stat_storage) ((stat_storage).statEnabled)

/******************************************************************************
 *  TYPE DEFINITION
 *****************************************************************************/

/** Definition of ISR trigger configuration */
typedef enum
{
    MSTEP_C_ISR_LEVEL_SENSITIVE = 0u, /**<Pin IRQ level sensitive                        */
    MSTEP_C_ISR_RISING_EDGE     = 1u, /**<Pin IRQ rising edge sensitive                  */
    MSTEP_C_ISR_FALLING_EDGE    = 2u, /**<Pin IRQ falling edge sensitive                 */
    MSTEP_C_ISR_BOTH_EDGES      = 3u  /**<Pin IRQ both rising and falling edge sensitive */
} MSTEP_E_IsrConfig;

/** Definition of DES process direction */
typedef enum
{
    MSTEP_C_DES_ENCRYPT = 1u, /**<DES Encryption process */
    MSTEP_C_DES_DECRYPT = 2u  /**<DES Decryption process */
} MSTEP_E_DESDirection;

/** Definition of DES cyphering mode */
typedef enum
{
    MSTEP_C_DES_ECB_MODE = 1u, /** DES Electronic Code Book cypher mode */
    MSTEP_C_DES_CBC_MODE = 2u /** DES Cypher Block Chaining mode       */
} MSTEP_E_DESMode;

/** Definition of the 16 bits parts of a 32 bit to scramble */
typedef enum
{
    MSTEP_C_SCRAMBLE_LSB = 0u, /**< Scramble the 16 LSB of a 32 bits */
    MSTEP_C_SCRAMBLE_MSB = 1u  /**< Scramble the 16 MSB of a 32 bits */
} MSTEP_E_ScramblePart;

/** Definition of the active CAN bus */
typedef enum
{
    MSTEP_C_CAN_ALPHA =   0u, /**< CAN active bus : Alpha */
    MSTEP_C_CAN_BETA  =   1u, /**< CAN active bus : Beta  */
    MSTEP_C_NO_BUS    = 255u
} MSTEP_E_CanActiveBus;

/** Structure containing information related to the vital stamp */

typedef struct
{
    INT32U pCrcTable[MSTEP_C_VITALSTAMP_SIZE]; /**<Table containing the CRC32 to check 2oo2 */
} MSTEP_T_VitalStamp;

/** Definition of format of the data to be stored in IODB */

typedef struct
{
    INT32U dataId; /**<Identifier of the data to be written in the
                    * database. Range of dataId value is [1..128].
                      A dataId equal to zero, is a dataId not configured */
    INT32U value;  /**<Value of the data to be stored into the database
                    * (note only the configured bit will be taken from the
                    * 32 bits */
} MSTEP_T_IodbData;

/** Time Stamp type
 * CANOpen DS301 standard format */

typedef struct
{
    INT32U ms;  /**<Milliseconds since midnight          */
    INT16U day; /**<Number of days since january 1, 1984 */
} MSTEP_T_CanTimeOfDay;

/** Definition of MAC address type */
typedef INT8U MSTEP_T_MacAddr[MSTEP_C_ETH_MAC_SIZE];
#ifdef ALSTOM_CONFIG_CPU_B
/** Structure used to pass the max propagation delay observed on normal and redunded network */

typedef struct
{
    INT32U sMaxDlyN; /**< Max propagation delay on normal network */
    INT32U sMaxDlyR; /**< Max propagation delay on redunded network */
}MSTEP_T_MaxRedIdPropagationDly;

/** Structure used to pass the max sequence number shift observed on normal and redunded network */

typedef struct
{
    INT32U sMaxSeqNbN; /**< Max propagation delay on normal network */
    INT32U sMaxSeqNbR; /**< Max propagation delay on redunded network */
}MSTEP_T_MaxRedIdSequenceNb;

#endif

/** Socket ID */
typedef INT32U MSTEP_T_SocketID;

/* "tftp" */
/** Defines the type of exchange of the connection */
typedef enum
{
    TFTP_C_CONNECTION_READ,   /**< Read connection */
    TFTP_C_CONNECTION_WRITE,  /**< Write connection */
    TFTP_C_CONNECTION_UNKNOWN /**< Used to check correctness of connection type */
} MSTEP_E_TftpConnectionType;

/** Defines the service connection id identifier */
typedef INT32U MSTEP_T_TftpServiceConnectionId;

/** Define a function's pointer type which is called when a new TFTP
    file transfer request is received for the associated service.

    \param connectionName - In -
            This is the filename requested to the TFTP server. The
            format of the filename will be of the following form:
            'XXX_YYYY...'. XXX is the name of the service associated
            to the opening request. YYYY... is the remaining of the
            filename, and can be freely interpreted by the service, to
            give some parameters to the service, for example.

    \param remoteIpAddr - In -
            IP if the TFTP client which have realized request.

    \param type - In - Type of TFTP request. It can only be
            TFTP_C_CONNECTION_READ of TFTP_C_CONNECTION_WRITE.

    \param pId - Out -
            Identifier of the connection. This value has to be chosen
            by the TFTP service to identify the connection. This value
            will not be used by the kernel. It will be passed as-is to
            the close function callback (\see
            MSTEP_T_TftpCloseConnectionCB).

    \param pBuffer - Out -
            Pointer to the buffer which will be used for the TFTP
            transfer. For a 'read' connection, the entire buffer will
            be send to the client. For a 'write' connection, the
            buffer will be used to receive data sent by the client. In
            this last case the client choose the size of data to be
            transfered, so the buffer may not be entirely written. So
            this buffer has to be able to receive the maximum
            potential size of data which can be received. If the
            buffer is too small, the transfer will fail. The Kernel
            will take care to manage the TFTP fragmentation if needed.

    \param pMaxSize - Out - Size of buffer given by pBuffer.

    \return ALSTOM_T_Status - Result of the connection opening. If the
    request is accepted, the function returns ALSTOM_C_NO_ERROR. In
    all other cases, the connection request will be rejected.
 */
typedef ALSTOM_T_Status(*MSTEP_T_TftpOpenConnectionCB)(const CHAR * const connectionName,
                                                       INT32U remoteIpAddr,
                                                       MSTEP_E_TftpConnectionType type,
                                                       MSTEP_T_TftpServiceConnectionId * pId,
                                                       INT8U ** pBuffer,
                                                       INT32U * pMaxSize);

/** Define a function's pointer type which is called when a TFTP file
    transfer is finished. The function is called when all fragments
    have been transfered successfully, or if the transfer has failed
    and had been aborted.

    \param id - In -
        Identifier of the connection. It is the value returned when the
        connection has been opened (\see MSTEP_T_TftpOpenConnectionCB)

    \param status - In -
        Result of the transfer. If it is equal to ALSTOM_C_NO_ERROR,
        then the transfer has been realized successfully. All other
        values mean that the transfer has failed and has been aborted.

    \param size - In -
        Size of transfered data. For a successful 'read' transfer,
        this value is expected to be the size of the buffer given by
        the MSTEP_T_TftpOpenConnectionCB function. For a 'write'
        connection, it is the size of data sent by the client.

*/
typedef void (*MSTEP_T_TftpCloseConnectionCB)(MSTEP_T_TftpServiceConnectionId id, ALSTOM_T_Status status, INT32U size);

/** Define a function's pointer type for guest application Isr callback */
typedef void (*MSTEP_T_IsrFunctionPtr)(void);

/** PDA area identifier type */
typedef const void * MSTEP_T_PDAReserveId;

/* "stat" */
/* "bist" */
/* "iodb" */
/** stopwatch states */
typedef enum
{
    STAT_C_STOPWATCH_STOPPED,  /**< the stopwatch is stopped */
    STAT_C_STOPWATCH_RUNNING   /**< the stopwatch is running */
}STAT_E_StopwatchState;

/** time structure */

typedef struct
{
    INT32U msTimePart;  /**< elapsed time ms*/
    INT16U usTimePart;  /**< elapsed time us*/
}STAT_T_Timestamp;

/** high precision stopwatch */

typedef struct
{
    STAT_T_Timestamp startTime;             /**< last start time */
    STAT_T_Timestamp elapsedTime;           /**< elapsed time when stopped */
    STAT_E_StopwatchState stopwatchState;   /**< current state */
}STAT_T_Stopwatch;

/** Statistic record */

typedef struct
{
    INT32U recordValue;                 /**< value of the statistic */
    STAT_T_Timestamp recordTimeStamp;   /**< time-stamp of the statistic value */
}STAT_T_StatRecord;

/** Statistic storage */

typedef struct
{
    BOOLEAN statEnabled;                    /**< indicates if the statistic is enabled and values stored 记录功能使能标志*/
    STAT_T_StatRecord *statRecordsArray;    /**< array of statistic records 指向一个record的首地址*/
    INT8U nextRecordPosition;               /**< position of the next record to write 下一个record的起始位置*/
    INT8U nbStoredRecords;                  /**< number of stored records 当前存了这么多个record（<=maxStoredRecords）*/
    INT8U maxStoredRecords;                 /**< maximum number of stored records 最多存这么多个record（代码指定）*/
    INT32U minRecordValue;                  /**< global minimum value 所有曾经记录的record中（不止当前限定的maxStoredRecords个记录），数值最小的*/
    INT32U maxRecordValue;                  /**< global maximum value 所有曾经记录的record中（不止当前限定的maxStoredRecords个记录），数值最大的*/
    INT32U totalNbValues;                   /**< global number of processed values 所有曾经被处理（求和）过的record的总个数。当所有记录总和>=0xFFFFFFFF则不再增加；或者当自身>=0xFFFFFFFF则不再对记录数据求和处理。（totalNbValues可能小于/等于/大于maxStoredRecords）*/
    INT32U valuesSum;                  /**< global sum of processed values 所有曾经记录的record的求和结果，<=0xFFFFFFFF。当超过0xFFFFFFFF时，则不再求和，保持为0xFFFFFFFF；或者当历史所有记录个数达到0xFFFFFFFF时则停止求和，保持上次的值*/
}STAT_T_StatStorage;

/** Type used to store the commom time */

typedef struct
{
    INT16U exp;          /**< Number cycle roll over*/
    INT16U cycle;           /**< current cycle number*/
}IODB_T_Time;

/* CR_Reference 2214 : Suppression of static usage for safety flag notification */
/** Typedef to use for function MSTEP_F_SafetyFlagBreak. This typedef defines the notification
 *  that kernel will call when MSTEP_F_SafetyFlagBreak will successfully finished.
 *  Take care to use a static variable as the kernel will not copy any informations but will
 *  directly used the variable provided by user.*/

typedef struct
{
    /** Flag group into which notification must be made */
    OSW_T_pFLAG_GRP pNotifFlagGroup;
    /** Flag value to used */
    OSW_T_FLAGS notifFlagValue;
    /** Action to be realized on the given flag value in the flag group */
    OSW_T_FLAG_ACT action;
} BIST_T_FuseInFlashFlagNotifInfo;

/******************************************************************************
 *  GLOBAL VARIABLES OF MODULE
 *****************************************************************************/

/******************************************************************************
 *  API FUNCTION PROTOTYPE
 *****************************************************************************/

/**
 ******************************************************************************
 * \par Description:
 *      Return the guest task ID of the current task (the task from which this
 *      function is called)
 *
 * \par Fault cases:
 *      - EVT_C_SAFETY_CORRUPTED if the function is not called from a guest
 *        task.
 *
 * \return MSTEPINC_E_TaskID: Guest task ID of the current task
 *
 * \note This function can be used to determine the ID of the current guest
 *      task. It is more appropriate than function OSW_F_TaskPrioGet() that
 *      returns the real priority of the task among all task (including kernel
 *      tasks)
 *****************************************************************************/
MSTEPINC_E_TaskID MSTEP_F_GuestTaskIdGet(void);

/**
 ******************************************************************************
 * \par Description :
 *      Inform SW watchdog that the task is passed at the defined point:
 *      Reload the task SW watchdog with its initial value.
 *
 * \par Fault cases:
 *      - EVT_C_SAFETY_CORRUPTED in case of no task was found
 *
 * \note Only one call is allowed and mandatory by cycle per task.
 *****************************************************************************/
void MSTEP_F_TaskFlagSet(void);

/**
 ******************************************************************************
 * \par Description:
 *      This function is used to indicate that a new 2oo2 exchange cycle is
 *      beginning and that a new cycle identifier must be calculated.
 *      The cycle identifier is used as freshness counter for data exchanged
 *      during the cycle and for the safety data voting.
 *
 * \par Fault cases:
 *      None
 *
 * \return INT32U:
 *         cycleId of the cycle.
 *
 * \note CycleId is computed using LFSR (Linear Feedback Shift
 *       Register) algorithm (evolved at each cycle).\n
 *       Cycle Id is different for each tasks as initialization seed differ.
 *****************************************************************************/
INT32U MSTEP_F_K2oo2CycleBegin(void);

/**
 ******************************************************************************
 * \par Description:
 *      This function ends the current cycle by voting the
 *      vital data computed on the two CPU during cycle.  Diversification
 *      is done on CRC for each CPU. This ensure that a CRC calculed
 *      by a CPU could not be computed directly by the other without
 *      transformation. This is done to avoid data reflexion and
 *      origin check. The vote realized by this function is performed
 *      with an exchange of data with a timeout of 500 ms.
 *
 * \par Fault cases:
 *      - EVT_C_NULL_PTR_ERROR if pVitalStamp is a NULL pointer
 *
 * \param pVitalStamp - in - Range: [!NULL]\n
 *        Pointer to Structure containing crc on vital data computed. Unused
 *        values in the array of the structure must be correctly initialized,
 *        since they will computed as other values.
 * \param functionId - In - Range: None\n
 *        Id of K2OO2 function.
 * \param line - In - Range: None\n
 *        Line from where the function was called.
 *
 * \note This function SHALL not be called directly. The MSTEP_F_K2oo2CycleEnd macro shall be
 *       used instead.
 *
 * \note The CycleId is used as freshness counter to ensure that the
 *       CRC computed in this function belong to the cycle.
 *
 *****************************************************************************/
void MSTEP_F_K2oo2CycleEndExt(const MSTEP_T_VitalStamp* const pVitalStamp, INT8U functionId, INT16U line);

/**
 ******************************************************************************
 * \par Description:
 *      This function send to distant CPU and wait last fragment send. Check
 *      that the ack is received before the module timeout. Cycle Id is
 *      transmitted with the data to ensure freshness check. Data are protected
 *      against reflexion by using 2 different CRC algo
 *
 * \par Fault cases:
 *      - EVT_C_OUT_OF_RANGE_ERROR if timeout is 0
 *      - EVT_C_NULL_PTR_ERROR if pBuf is a NULL pointer
 *
 * \param pBuf   - in - Range: [!NULL]\n
 *        Pointer to the buffer where message to send is stored
 * \param size   - in - Range: LIMIT will be defined to avoid too much
 *                             fragmentation and timeout elapse.\n
 *        Size of the data to transfer
 * \param timeout - in - Range: None\n
 *        Applicative timeout
 * \param functionId - In - Range: None\n
 *        Id of K2OO2 function.
 * \param line - In - Range: None\n
 *        Line from where the function was called.
 *
 * \note This function SHALL not be called directly. The MSTEP_F_K2oo2CpuSend macro shall be
 *       used instead.
 *
 * \note MTU (Message Transfert Unit) is limited to 200 bytes, else,
 *       fragmentation is used.
 *
 * \see MSTEP_F_K2oo2CpuWaitExt()
 *
 *****************************************************************************/
/* Implements <STEP_SwAD_0814> */
void MSTEP_F_K2oo2CpuSendExt(const INT8U* const pBuf,
                             const INT32U       size,
                             const INT16U       timeout,
                             INT8U        functionId,
                             INT16U       line);

/**
 ******************************************************************************
 * \par Description:
 *      This function provide blocking wait on message
 *      from distant CPU.  CycleId is transmitted with the data to
 *      ensure that received informations are from the waited task. The cycleId
 *      is also checked as a freshness counter. If data received do not belong to
 *      the current cycle, a software fuse will be triggered.
 *
 * \par Fault cases:
 *      - EVT_C_NULL_PTR_ERROR if pBuf is a NULL pointer
 *
 * \param pBuf   - in - Range: [!NULL]\n
 *        Pointer to the buffer where message is received
 * \param size   - in - Range: None\n
 *        Size of the data awaited
 * \param timeout - in - Range: None\n
 *        Applicative timeout
 * \param functionId - In - Range: None\n
 *        Id of K2OO2 function.
 * \param line - In - Range: None\n
 *        Line from where the function was called.
 *
 * \note This function SHALL not be called directly. The MSTEP_F_K2oo2CpuWait macro shall be
 *       used instead.
 *
 * \see MSTEP_F_K2oo2CpuSendExt()
 *
 *****************************************************************************/
/* Implements <STEP_SwAD_0814> */
void MSTEP_F_K2oo2CpuWaitExt(INT8U* const pBuf,
                             const INT32U       size,
                             const INT16U       timeout,
                             INT8U        functionId,
                             INT16U       line);

/**
 ******************************************************************************
 * \par Description:
 *      This function provide blocking message exchange between CPU
 *      CycleId is transmitted with the data to ensure that received informations
 *      are from the waited task. The cycleId is also checked as a freshness
 *      counter. If data received do not belong to the current cycle, a software
 *      fuse will be triggered.
 *
 * \par Fault cases:
 *      - EVT_C_NULL_PTR_ERROR if pBufIn or pBufOut is a NULL pointer
 *
 * \param pBufIn  - in - Range: [!NULL]\n
 *        Pointer to the buffer where message received is stored
 * \param pBufOut - in - Range: [!NULL]\n
 *        Pointer to the buffer where message to transmit is stored
 * \param size    - in - Range: None\n
 *        Size of the data awaited
 * \param timeout - in - Range: None\n
 *        Applicative timeout
 * \param functionId - In - Range: None\n
 *        Id of K2OO2 function.
 * \param line - In - Range: None\n
 *        Line from where the function was called.
 *
 * \note This function SHALL not be called directly. The MSTEP_F_K2oo2CpuExchange macro shall be
 *       used instead.
 *
 * \note Size of data exchanged shall be identical.
 *
 * \see MSTEP_F_K2oo2CpuSendExt()
 *
 *****************************************************************************/
/* Implements <STEP_SwAD_0814> */
void MSTEP_F_K2oo2CpuExchangeExt(INT8U* const pBufIn,
                                 const INT8U*       pBufOut,
                                 const INT32U       size,
                                 const INT16U       timeout,
                                 INT8U        functionId,
                                 INT16U       line);

/**
 ******************************************************************************
 * \par Description:
 *      This function compute the CRC-16 CCITT checksum of the buffer given in
 *      argument.\n
 *      CRC is defined by:
 *      - Polynom: 0x1021
 *      - Initial value set to 0xFFFF
 *      - No reflection on input data
 *      - No reflection on output result
 *      - Xor final value set to 0x0000
 *      - CRC check have 0x29B1 value, check is done against "123456789"
 *
 * \par Fault cases:
 *      - pBuffer is NULL pointer
 *      - pCrc is NULL pointer
 *
 * \param pBuffer - in - Range: [!NULL]\n
 *        Pointer to the buffer
 * \param length  - in - Range: None\n
 *        Length of the buffer
 * \param pCrc    - out - Range: [!NULL]\n
 *        Pointer to the CRC result
 *****************************************************************************/
void MSTEP_F_CryptlibCRC16CCITTCompute(const INT8U*  const pBuffer,
                                       const INT32U        length,
                                       INT16U* const pCrc);

/**
 ******************************************************************************
 * \par Description :
 *      This function compute the CRC-32 CCITT configuration key checksum on
 *      the buffer given in argument.\n
 *      CRC is defined by:
 *      - Polynom : 0x04C11DB7
 *      - Initial value set to 0xFFFFFFFF (provided as a parameter).
 *      - No reflection on input data
 *      - No reflection on output result
 *      - Xor final value set to 0x00000000
 *      - CRC check have 0x376E6E7 value, check is done against "123456789"
 *
 * \par Fault cases:
 *      - pBuffer is NULL pointer
 *      - pCrc is NULL pointer
 *      - pInitCrc is NULL pointer
 *
 * \param pBuffer - in  - Range: [!NULL]       \n
 *        Pointer to the buffer
 * \param length  - in  - Range: None          \n
 *        Length of the buffer
* \param pInitCrc - in  - Range: [!NULL]       \n
 *        Pointer on the initial CRC value
 * \param pCrc    - out - Range: [!NULL]       \n
 *        Pointer to the result
 *****************************************************************************/
void MSTEP_F_CryptlibCRC32CCITTCompute(const INT8U*  const pBuffer,
                                       const INT32U        length,
                                       const INT32U* const pInitCrc,
                                       INT32U* const pCrc);

/**
 ******************************************************************************
 * \par Description :
 *      This function compute the CRC-32 FSFB2 channel 1 checksum on the buffer
 *      given in argument.\n
 *      CRC is defined by:
 *      - Polynom: 0x0FC22F87 (FSFB2 channel 1)
 *      - Initial value set to 0xFFFFFFFF
 *      - No reflection on input data
 *      - No reflection on output result
 *      - Xor final value set to 0x00000000
 *      - CRC check have 0x5A21FB08 value, check is done against "123456789"
 *
 * \par Fault cases:
 *      - pBuffer is NULL pointer
 *      - pCrc is NULL pointer
 *
 * \param pBuffer - in  - Range: [!NULL]       \n
 *        Pointer to the buffer
 * \param length  - in  - Range: None          \n
 *        Length of the buffer
 * \param pCrc    - out - Range: [!NULL]       \n
 *        Pointer to the result
 *****************************************************************************/
void MSTEP_F_CryptlibCRC32FSFB2ChanOneCompute(const INT8U*  const pBuffer,
                                              const INT32U        length,
                                              INT32U* const pCrc);

/**
 ******************************************************************************
 * \par Description :
 *      This function cipher/decipher the buffer given in argument using DES
 *      algorithm.
 *      - DES encryption is calculated using ColdFire hardware accelerator
 *      - Function is protected against abnormal execution time
 *
 * \note Processing can be delayed as common resource is used. max delay
 *       is 5ms.
 *
 * \par Fault cases:
 *      - EVT_C_NULL_PTR_ERROR if pBufferIn or PBufferout is NULL pointer
 *
 * \param pBufferIn       - in  - Range: [!NULL]       \n
 *        Pointer to the buffer to be processed
 * \param lengthIn        - in  - Range: [0..1024]          \n
 *        Size of the input buffer
 * \param pBufferOut      - out - Range: [!NULL]       \n
 *        Pointer to the processed buffer
 * \param key             - in  - Range: None          \n
 *        64 bits key used for ciphering/deciphering the buffer
 * \param CBCInitVector   - in  - range: None    \n
 *        64 bits initialization vector used for CBC cypher mode
 * \param eCryptDirection - in  - Range: [MSTEP_C_DES_ENCRYPT..MSTEP_C_DES_DECRYPT]  \n
 *        Direction of the encryption process
 * \param cypherMode      - in  - Range: [MSTEP_C_DES_ECB_MODE..MSTEP_C_DES_CBC_MODE] \n
 *        DES cypher mode
 *
 * \return ALSTOM_T_Status:
 *      - ALSTOM_C_ERROR if calculation takes too long time
 *      - ALSTOM_C_ERROR if error occurs during block processing
 *      - ALSTOM_C_ERROR if semaphore posting fails
 *      - ALSTOM_C_NO_ERROR otherwise
 *
 * \note Length MUST BE a multiple of 8
 *
 * \note When used with ECB mode, CBCInitVector is unused.
 *****************************************************************************/
ALSTOM_T_Status MSTEP_F_CryptlibDESCompute
(const INT32U* const        pBufferIn,
 const INT32U               lengthIn,
 INT32U*              pBufferOut,
 const INT32U               key[2],
 const INT32U               CBCInitVector[2],
 MSTEP_E_DESDirection eCryptDirection,
 MSTEP_E_DESMode      cypherMode);

/**
 ******************************************************************************
 * \par Description :
 * Read from IODB data.\n
 * \note Data access is done through the mapping as configured in Key.
 *
 * \par Limitation:
 *      see FeatureIODB for details
 *
 * \par Fault cases:
 *      - pValues is NULL pointer
 *
 * \param nbElem  - in  - range: None \n
 *        Number of element to read into the database
 * \param pValues - in/out - range: [!NULL] \n
 *        Pointer on the readed data
 *
 * \return ALSTOM_T_Status:
 *         - ALSTOM_C_ERROR if something fails
 *         - ALSTOM_C_NO_ERROR else.
 *
 * \note The max size of data to read into the database is limited to 32 bits.
 *       Only the number of bit defined in the configuration will be returned
 *       in the database. Data alignment is LSB.
 *       The content of the pValues array can contain duplicate entries,
 *       no check is done by the kernel and every entry will be properly filled.
 *
 * \see MSTEP_F_IodbSubmit()
 *****************************************************************************/
ALSTOM_T_Status MSTEP_F_IodbRequest(const INT32U                  nbElem,
                                    MSTEP_T_IodbData* const pValues);

/**
 ******************************************************************************
 * \par Description :
 * Submit for storage inside IODB and 2oo2 verification the data provided, the
 * write into database is not immediate. \n
 * \note Data access is done through the mapping as configured in Key.\n
 *
 * \note SAFETY: The user shall write data to restrictive if needed, no freshness of
 * data is managed in IODB for the data written from this API. \n
 * Moreover, in the case of a STEPPER, if the written data are stored in a TPDO,
 * the standby board IODB will be filled with this data from the CAN. The user
 * shall take care that after a switch from Standby to Normal the new Normal
 * board IODB contains this data coming from the "old normal" and will never be
 * refreshed by the kernel.
 *
 * \par Fault cases:
 *      - pInfo is NULL pointer
 *
 * \par Limitation:
 *      see FeatureIODB for details
 *
 * \param nbElem - in - range: None \n
 *        Number of element to write into the database
 * \param pInfo  - in - range: [!NULL]       \n
 *        Pointer to the data to be written in the database
 *
 * \return None
 *
 * \note The max size of data to write into the database is limited to 32 bits.
 *       Only the number of bit defined in the configuration will be uploaded
 *       in the database, other bits will be ignored. Data alignment is LSB.
 *
 * \see MSTEP_F_IodbRequest()
 *****************************************************************************/
void MSTEP_F_IodbSubmit(const INT32U                  nbElem,
                        const MSTEP_T_IodbData* const pInfo);

/**
 ******************************************************************************
 * \par Description:
 *      Reserve a new persistent area.
 *
 *      Persistent areas are stored in two sectors of flash memory. The usage of
 *      two sectors enable to provide a backup sector in case of error while
 *      reading the main one. Indeed, such errors are very likely to occur if
 *      a power-off occurs while writing data into flash for example.
 *
 *      However, retrieving previous data is not always a good solution. If the
 *      freshness of data is a safety concern, then the parameter
 *      bSafetyFreshness should be set to TRUE. In this case, and if the most
 *      recent flash sector is corrupted, then previous data will never be given
 *      back. Instead, the read operation on the area will return an error.
 *
 *      Read and write accesses to the data of the area does not directly access
 *      to the flash memory. They access to a copy in RAM. It enables fast
 *      access to the data of the area without depending on slow flash
 *      accesses. Write operations into flash memory are called 'flush'. They
 *      are realized every 3 hours or on demand. Furthermore it is possible to
 *      transparently write into the area during a flush. It is made possible
 *      with the use of front and back buffers, and this is why two buffers are
 *      asked during the reservation of the area (pFirstBuffer and
 *      pSecondBuffer). Front and back buffer management is entirely managed by
 *      the kernel and the caller shall never access to pFirstBuffer and
 *      pSecondBuffer buffers directly.
 *
 *      Concurrent accesses between the kernel and another task is completely
 *      managed. It means that a task can read or write from/to a PDA, which is
 *      being flushed in the same time. This is the purpose of the use of double
 *      buffers.
 *
 *      Furthermore two tasks can access to two different PDA without any
 *      problem. However two tasks cannot access to a same PDA. So, it is the
 *      responsibility of the caller to take care to correctly managed this kind
 *      of concurrent access.
 *
 *      The maximum number of PDA which can be reserved is:
 *      MSTEP_C_PDA_MAX_RESERVATION.
 *
 *      The total PDA size which can be reserved is:
 *      MSTEP_C_PDA_MAX_TOTAL_SIZE
 *
 * \par Fault cases:
 *      - Parameter range error
 *      - Too many PDA
 *      - Total PDA size exceeded
 *
 * \param uniqId - In - Range: None \n
 *              Unique identifier of the area.
 *
 * \param bSafetyFreshness - In - Range: None \n
 *              Tell if the freshness of the area is a safety concern
 *
 * \param pFirstBuffer - In - Range: [!NULL] \n
 *              First buffer used to manage front/back buffering.
 *
 * \param pSecondBuffer - In - Range: [!NULL] \n Second buffer used to manage
 *              front/back buffering.
 *
 * \param size - In - Range: [>0] \n
 *              Size of the area. Of course, this is also the size of
 *              buffers pointed by pFirstBuffer and pSecondBuffer.
 *
 *
 * \return MSTEP_T_PDAReserveId - Identifier of the reserved area. This value
 *  has to be used for all accesses to the area.
 *
 * \note This function shall be called during the 'Create' callback of tasks,
 * not before, not after. However the returned area identifier will not be
 * usable yet. It will be usable in other callbacks ('Config', 'Start',
 * or 'MainLoop') of tasks.
 *
 * Absolutely no consistency between each CPU is realized. The caller is free to
 * reserve some area on a CPU and not on the other. The content of an area
 * reserved on each CPU can be entirely different.
 *****************************************************************************/
MSTEP_T_PDAReserveId MSTEP_F_PDAReserveArea(INT16U uniqId, BOOLEAN bSafetyFreshness,
                                            void * pFirstBuffer, void * pSecondBuffer, INT32U size);

/**
 ******************************************************************************
 * \par Description:
 *      Read data from a previously reserved persistent area.
 *
 *      The execution time of this function is almost the time needed to copy
 *      data from PDA to the given buffer.
 *
 * \par Fault cases:
 *      - Parameter range error
 *
 * \param id - In - Range: None \n
 *              Identifier of the reserved area
 *
 * \param offset - In - Range: [<area size] \n
 *              Byte offset in the area.
 *
 * \param size - In - Range: [>0] \n
 *              Size of data to read from the area.
 *
 * \param pBuffer - Out - Range: [!NULL] \n
 *              Pointer to buffer which will receive data.
 *
 *
 * \return ALSTOM_T_Status - Status of operation. ALSTOM_C_NO_ERROR if no error
 * occurred. Otherwise, it returns ALSTOM_C_ERROR. It can happen if data written
 * into flash memory have been corrupted and no backup data are available. It
 * also happen if data have never been written and flushed.
 *
 * \note See MSTEP_F_PDAReserveArea() documentation for informations
 * about concurrent accesses.
 *
 *****************************************************************************/
/* Implements <STEP_SwAD_0815> */
ALSTOM_T_Status MSTEP_F_PDARead(MSTEP_T_PDAReserveId id, INT32U offset, INT32U size, void * pBuffer);

/**
 ******************************************************************************
 * \par Description:
 *      Write data to front buffer. Data will only be stored into Flash when
 *      the next flush will occur.
 *
 *      The function can be called when a flush is in progress, thanks to double
 *      buffering. However if this function is called while a flush is in
 *      progress and only a part of the PDA is written, then it is needed to
 *      copy the back buffer to the front buffer, and then realize the write of
 *      data. It is transparent to the caller, except about timing. Indeed, in
 *      addition to the time of writing the given data, the time needed to copy
 *      the entire PDA from one buffer to the other has to be added. If the
 *      entire PDA is written, no additional copy is realized, so this additional
 *      time is not added.
 *
 * \par Fault cases:
 *      - Parameter range error
 *
 * \param id - In - Range: None \n
 *              Identifier of the reserved area
 *
 * \param offset - In - Range: [<area size] \n
 *              Byte offset in the area.
 *
 * \param size - In - Range: [>0] \n
 *              Size of data to write into the area.
 *
 * \param pBuffer - Out - Range: [!NULL] \n
 *              Pointer to buffer containing data to write.
 *
 * \note It has to be noted that this function does not directly write into
 * flash memory. This operation is realized during the flush operation which
 * occurs every 3 hours or on demand with a dedicated function.
 *
 * \note See MSTEP_F_PDAReserveArea() documentation for informations
 * about concurrent accesses.
 *
 *****************************************************************************/
/* Implements <STEP_SwAD_0815> */
void MSTEP_F_PDAWrite(MSTEP_T_PDAReserveId id, INT32U offset, INT32U size, const void * pBuffer);

/**
 ******************************************************************************
 * \par Description:
 *      This function asks to flush all areas into flash memory.  The flush
 *      operation is realized asynchronously. This is why a flag notification
 *      can be configured. The flag notification is realized when the asked
 *      flush is finished.
 *
 *      The flush time depends on multiple factors:
 *      - The number of PDA to be flushed
 *      - The size of PDA to be flushed
 *      - The number of PDA which have a safety freshness (indeed, it needs
 *         additional write operations in flash)
 *      - The execution of the previous flush operation which is not yet
 *        finished.
 *
 * \par Fault cases:
 *      None
 *
 * \param pFlagGroup - In - Range: None \n
 *              Flag group into which flush notification must be made. If NULL,
 *              no notification is realized.
 *
 * \param flagValue - In - Range: None \n
 *              Flag value posted into flag group.
 *
 * \param action - In - Range: None \n
 *              Action realized on flag during posting
 *
 *
 * \note A flush operation realize erase and write access to flash memory. The
 * caller should take care to not call this function too often in order to not
 * reduce the life time of the flash component.
 *
 * If a flush is asked, but no new data need to be programmed in flash, then no
 * operation is realized. The notification (if configured) will occur without
 * having erased/written data into the flash component.
 *
 *****************************************************************************/
void MSTEP_F_PDAAskFlush(OSW_T_pFLAG_GRP pFlagGroup,
                         OSW_T_FLAGS flagValue, OSW_T_FLAG_ACT action);

/**
 ******************************************************************************
 * \par Description :
 *      This function gives access to the application configuration data
 *      contained in key.
 *
 * \par Fault cases :
 *      - EVT_C_NULL_PTR_ERROR if pGuestSubArea is NULL pointers.
 *
 * \param pGuestSubArea - out - Range: [!NULL]\n
 *        Pointer to guest configuration parameters data structure
 *
 * \note If configuration data are not available when this function is called
 *       the software is set into safe state.
 *****************************************************************************/
void MSTEP_F_ConfigGuestSubAreaGet(const INT8U **pGuestSubArea);

/**
 ******************************************************************************
 * \par Description:
 *      This function is used to get the MAC address of the current CPU which
 *      is stored into the electronic stamp.
 *      It will be available in case the board mode is not GUEST_NOETH and
 *      the functional mode is not BOOT_FAILED.
 *
 * \par Fault cases:
 *      - None
 *
 * * \par Pseudo-code:
 *      -# If IP Stack information is available
 *        -# Obtains the MAC address value
 *
 * \param macAddr - Out - Range: none \n
 *              MAC address returned by the function
 *
 * \return BOOLEAN - TRUE if MAC address value was successfully obtained, FALSE otherwise.
 *
 *****************************************************************************/
BOOLEAN MSTEP_F_ConfigBoardEthMacAddressGet(MSTEP_T_MacAddr macAddr);

/**
 ******************************************************************************
 * \par Description :
 *      This function gives access to the position of the board in the
 *      equipment.
 *
 * \par Fault cases :
 *      - EVT_C_NULL_PTR_ERROR if pRackNumber and pSlotNumber are NULL pointers.
 *
 * \param pRackNumber - out - Range: [!NULL]\n
 *        Pointer to the number of the rack the board is in.
 * \param pSlotNumber - out - range: [!NULL]\n
 *        Pointer to the position number of the slot the board is in.
 *
 * \note Rack number goes from 1 to 3 and Slot Number goes from 0 to 15.
 *       If position identification is not available, zero are returned for
 *       both values.
 *****************************************************************************/
void MSTEP_F_ConfigBoardPositionGet(INT8U *const pRackNumber,
                                    INT8U *const pSlotNumber);

/**
 ******************************************************************************
 * \par Description :
 *      This function gives the current date and time, using CANOpen format.
 *
 * \par Fault cases :
 *      - EVT_C_NULL_PTR_ERROR if pTime is NULL pointer.
 *
 * \param pTime - out - Range: [!NULL] \n
 *        Pointer to time structure \n
 *
 * \note Format of Time Stamp type is defined as follow:\n
 * 32 bits representing the numbers of milliseconds elapsed since midnight\n
 * 16 bits giving the number of days elapsed since the first January of 1984
 ******************************************************************************/
void MSTEP_F_TimeGet(MSTEP_T_CanTimeOfDay* const pTime);

/* CR_reference 1760  */
/**
 ******************************************************************************
 * \par Description:
 *      This function provide an access to the CommonTime.
 *      This time is synchronized on each CPU. The maximum drift is 15 ms.
 *      The CommonTime is available in operiational mode (NORMAL, STANBY and GUEST)
 *      which means when the kernel is completely started.
 *
 * \par Fault cases:
 *      - EVT_C_NULL_PTR_ERROR if pCommonTime is NULL.
 *
 * \param pCommonTime - out - Range: [!NULL]\n
 *        Pointer to the common time in ms.
 *        Set to 0 if the Common Time is not enabled.
 *
 * \return BOOLEAN - TRUE if the CommonTime is enabled.
 *                   FALSE else
 *****************************************************************************/
/* Implements <STEP_SwAD_1460> */
BOOLEAN MSTEP_F_CommonTimeGet(INT32U* pCommonTime);

/**
 ******************************************************************************
 * \par Description :
 *      This function returns the active CAN bus for the related CPU
 *
 * \par Fault cases :
 *      - None
 *
 * \return MSTEP_E_CanActiveBus
 * - MSTEP_C_CAN_ALPHA
 * - MSTEP_C_CAN_BETA
 *
 * \note The no bus available indication will never be returned by the function
 *       as if this case occurs the software will not function anymore.
 ******************************************************************************/
MSTEP_E_CanActiveBus MSTEP_F_CanActiveBusGet(void);

/**
 ******************************************************************************
 * \par Description :
 *      This function sets a GPIO configured in output direction.
 *
 * \par Fault cases:
 *      - EVT_C_OUT_OF_RANGE_ERROR if numGPIO is >= MSTEPINC_C_GPIO_NB_MAX,
 *
 * \par Global variable used:
 *      None
 *
 * \param numGPIO - In - Range: [MSTEPINC_C_GPIO_ID1...MSTEPINC_C_GPIO_ID16]\n
 *        Id of GPIO to be set.
 *
 * \see MSTEP_F_GpioSetOff()
 * \see MSTEP_F_GpioToggle()
 *****************************************************************************/
void MSTEP_F_GpioSetOn(MSTEPINC_E_GpioId numGPIO);

/**
 ******************************************************************************
 * \par Description :
 *      This function clears a GPIO configured in output direction.
 *
 * \par Fault cases:
 *      - EVT_C_OUT_OF_RANGE_ERROR if numGPIO is >= MSTEPINC_C_GPIO_NB_MAX
 *
 * \par Global variable used:
 *      None
 *
 * \param numGPIO - In - Range: [MSTEPINC_C_GPIO_ID1...MSTEPINC_C_GPIO_ID16]\n
 *        Id of GPIO to be cleared.
 *
 * \see MSTEP_F_GpioSetOn()
 * \see MSTEP_F_GpioToggle()
 *****************************************************************************/
void MSTEP_F_GpioSetOff(MSTEPINC_E_GpioId numGPIO);

/**
 ******************************************************************************
 * \par Description :
 *      This function toggles a GPIO configured in output direction.
 *
 * \par Fault cases :
 *      - EVT_C_OUT_OF_RANGE_ERROR if numGPIO is >= MSTEPINC_C_GPIO_NB_MAX
 *
 * \par Global variable used:
 *      None
 *
 * \param numGPIO - In - Range: [MSTEPINC_C_GPIO_ID1...MSTEPINC_C_GPIO_ID16]\n
 *        Id of GPIO to be toggled
 *
 * \see MSTEP_F_GpioSetOn()
 * \see MSTEP_F_GpioSetOff()
 *****************************************************************************/
void MSTEP_F_GpioToggle(MSTEPINC_E_GpioId numGPIO);

/**
 ******************************************************************************
 * \par Description :
 *      This function reads the state of a GPIO configured in input or output
 *       direction.
 *
 * \par Fault cases:
 *      - EVT_C_OUT_OF_RANGE_ERROR if numGPIO is >= MSTEPINC_C_GPIO_NB_MAX,
 *
 * \par Global variable used:
 *      None
 *
 * \param numGPIO - In - Range: [MSTEPINC_C_GPIO_ID1...MSTEPINC_C_GPIO_ID16]\n
 *        Id of GPIO to be read.
 *
 * \return MSTEPINC_T_GpioReadValue:
 *         - 0 if GPIO is low state,
 *         - !0 if GPIO is high state.
 *****************************************************************************/
MSTEPINC_T_GpioReadValue MSTEP_F_GpioRead(MSTEPINC_E_GpioId numGPIO);

/**
 ******************************************************************************
 * \par Description:
 *      This function is used to allow guest application to perform transmission
 *      of data on SPI. This function do not implement a specific protocol.\n
 *      The main process ensured by this function are:
 *          - Gets the semaphore dedicated to SPI module
 *          - Writes the buffer TxBuff in the QSPI Transmit RAM,
 *          - Writes the buffer pCommandBuff in the QSPI Command RAM,
 *          - Launch the transmission,
 *          - Waits for the end of the transmission (polling on QIR[SPIF] bit),
 *          - Reads the contains of Receive RAM and writes it into pRxBuff,
 *          - Releases the semaphore.
 *
 * \par Fault cases:
 *      - EVT_C_OUT_OF_RANGE_ERROR if nbDataToSend is out of ranges,
 *      - EVT_C_NULL_PTR_ERROR if pCommandBuff or pTxBuff or pRxBuff is null,
 *      - EVT_C_CONFIG_ERROR in case of unexpected board mode
 *      - EVT_C_OUT_OF_RANGE_ERROR if trying to use a wrong chip select
 *
 * \param nbDataToSend - in  - Range: [1...16]\n
 *        Number of data (or command) to be transmitted through SPI.
 * \param pCommandBuff - in  - Range: [!NULL]\n
 *        Pointer to a buffer containing commands to be applied by the QSPI
 *        module. \n
 *        Be careful that the content of the command buffer must be correctly
 *        set to drive the Chip Select Pin correctly. \n
 *        On Stepper the following chip select are available:
 *          - CS2 on CPU_A
 *          - CS1 and CS2 on CPU_B
 *        On guest the following chip select are available:
 *          - CS1 and CS2 on both CPU
 *        Furthermore CS3 is available on both CPU if BID is forced
 *        by application (cf. GUEST_F_SystemConfigure()). \n
 *        Correct values of QSPI_CS are 0x0D00 (CS1), 0x0B00 (CS2) and 0x0700 (CS3). (0 for active CS) \n
 *      Command RAM has the following structure : \n
 *              - bit 15   |  CONT   | Continuous \n
 *                                      value 0 : Chip selects return to inactive level when transfer is complete \n
 *                                      value 1 : Chip selects remain asserted after the transfer of 16 words
 *              - bit 14   |  BITSE  | Bits per transfer enable \n
 *                                      value 0 : 8 bits \n
 *                                      value 1 : 16 bits
 *              - bit 13   |   DT    | Delay after transfer enable \n
 *                                      value 0 : Default reset value \n
 *                                      value 1 : 213 ns
 *              - bit 12   |  DSCK   | Chip select to QSPI_CLK delay enable \n
 *                                  (see Coldfire Documentation)
 *              - bits 11-8 | QSPI_CS | Peripheral chip selects \n
 *                                      This bits map directly to QSPI_CS[3:0]
 *              - bits 7-0  |    -    | reserved, sould be cleared
 *      It has to be noted that the DT and DSCK bit shall always be
 *      set to 1, and the CONT bit of the last command word shall be
 *      set to 0.
 * \param pTxBuff      - in  - Range: [!NULL]\n
 *        Pointer to a buffer containing data to be sent by the QSPI module.
 * \param pRxBuff      - out - Range: [!NULL]\n
 *        Pointer to a buffer where data read by QSPI module shall be stored.
 *
 * \return ALSTOM_T_Status:
 *      - ALSTOM_C_ERROR if an error occurs
 *      - ALSTOM_C_NO_ERROR else.
 *
 * \note Content of pCommandBuff is checked before access. Software Fuse is
 *               triggered if chip select value is not valid.
 * \note This function use a semaphore to protect the hardware QSPI cell. This
 *       function shall not be used by SIL4 functions.
 *****************************************************************************/
ALSTOM_T_Status MSTEP_F_SpiProcess(const INT8U         nbDataToSend,
                                   const INT16U* const pCommandBuff,
                                   const INT16U* const pTxBuff,
                                   INT16U* const pRxBuff);

/**
******************************************************************************
 * \par Description :
 *      This function returns whether the application runs on CPU A or CPU B.
 *
 * \par Fault cases:
 *      None
 *
 * \par Global variable used:
 *      None
 *
 * \return MSTEPINC_E_CpuId:
 *         - MSTEPINC_C_CPU_A if application runs on CPU A,
 *         - MSTEPINC_C_CPU_B if application runs on CPU B,
 *         - MSTEPINC_C_CPU_ID_ERROR else
 *****************************************************************************/
MSTEPINC_E_CpuId MSTEP_F_CpuIdGet(void);

/**
 *****************************************************************************
 * \par Description:
 *      This function is used to assign an ISR to the guest interrupt.\n
 *
 * \note If this function is not called during initialization or called with
 *       a NULL pointer in parameter, interrupt vector will not be available.\n
 *
 * \par Fault cases:
 *      - EVT_C_NULL_PTR_ERROR if pIsrFunction is NULL
 *
 * \param pIsrFunction - in - range: none\n
 *        Pointer on the function which shall be linked to the interrupt pin
 *        provided.
 * \param isrConfig    - in - range [MSTEP_C_ISR_LEVEL_SENSITIVE..
 *                                   MSTEP_C_ISR_BOTH_EDGES] \n
 *        Configuration of the interrupt trigger.
 *
 *****************************************************************************/
void MSTEP_F_IsrConfigure(const MSTEP_T_IsrFunctionPtr pIsrFunction, const MSTEP_E_IsrConfig isrConfig);

/**
 *****************************************************************************
 * \par Description:
 *      This function shall be used to acknowledge the interrupt source.\n
 *
 * \par Fault cases:
 *      None
 *
 *****************************************************************************/
void MSTEP_F_IsrAck(void);

/**
 *****************************************************************************
 * \par Description:
 *      This function enable the interrupt source.\n
 *
 * \par Fault cases:
 *      None
 *
 *****************************************************************************/
void MSTEP_F_IsrEnable(void);

/**
 *****************************************************************************
 * \par Description:
 *      This function disable the interrupt source.\n
 *
 * \par Fault cases:
 *      None
 *
 *****************************************************************************/
void MSTEP_F_IsrDisable(void);

#ifdef ALSTOM_CONFIG_CPU_A
/**
 *****************************************************************************
 * \par Description:
 * This function sets a failure code with its context into the failure
 * table.
 *
 * \note Appearance date of the failure is set by the kernel.
 *
 * \par Fault cases:
 *      - EVT_C_OUT_OF_RANGE_ERROR if failureCode out of bounds.
 *      - EVT_C_NULL_PTR_ERROR if pFailureContext is NULL pointer.
 *
 * \param failureCode     - in - range: [MSTEPINC_C_MIN_FAILURE_CODE..
 *                                       MSTEPINC_C_MAX_FAILURE_CODE] \n
 *        Fault code to set
 * \param pFailureContext - in - range: [!NULL]\n
 *        Context string associated with the fault

 * \par Returns void
 *****************************************************************************/
void MSTEP_F_FailureCodeSet(MSTEPINC_T_FailureCode failureCode, const MSTEPINC_T_FailureContext* const pFailureContext);
#endif

#ifdef ALSTOM_CONFIG_CPU_A
/**
 *****************************************************************************
 * \par Description:
 *      This function clears a failure code into the failure table.
 *
 * \note If the fault to clear is not already set, command is ignored.
 *
 * \par Fault cases:
 *      - EVT_C_OUT_OF_RANGE_ERROR if failureCode out of bounds.
 *
 * \param failureCode     - in - range: [MSTEPINC_C_MIN_FAILURE_CODE..
 *                                       MSTEPINC_C_MAX_FAILURE_CODE] \n
 *        Fault code to clear.

 * \par Returns void
 *****************************************************************************/
void MSTEP_F_FailureCodeClear(MSTEPINC_T_FailureCode failureCode);
#endif

/**
 ******************************************************************************
 * \par Description:
 *      This function opens an UDP socket.
 *
 * \par Fault cases:
 *      - Parameter range error
 *
 *
 * \param port - In - Range: [16384..65535] \n
 *              Local UDP port to be opened
 *
 * \param pFifo - In - Range: [!NULL] \n
 *              FIFO task associated to the reception of data on the given
 *              UDP port.
 *
 *
 * \return MSTEP_T_SocketID - The opened socket.
 *
 * \note The FIFO associated to the socket will be used to store received
 *      message. A same FIFO can be used to store message from multiple
 *      sockets. However, in this case, it will not be possible to use
 *      the dedicated reception function (cf. MSTEP_F_UDPRecv()).
 *
 *****************************************************************************/
MSTEP_T_SocketID * MSTEP_F_UDPOpen(INT16U port, OSW_T_pEVENT pFifo, INT8U Eth_Index);


/**
 ******************************************************************************
 * \par Description:
 *      Close an UDP socket.
 *
 * \par Fault cases:
 *      - Parameter range error
 *
 *
 * \param pSocket - In - Range: [!NULL]
 *              Socket to be closed
 *
 *****************************************************************************/
void MSTEP_F_UDPClose(MSTEP_T_SocketID * pSocket);


/**
 ******************************************************************************
 * \par Description:
 *      Receive data from a socket.
 *
 * \par Fault cases:
 *      - Parameters range error
 *
 *
 * \param pSocket - In - Range: [!NULL] \n
 *              Socket on which message is waited
 *
 * \param pSrcAddr - Out - Range: [!NULL] \n
 *              Returns the source IP address of the received message
 *
 * \param pSrcPort - Out - Range: [!NULL] \n
 *              Returns the source port of the received message
 *
 * \param pData - Out - Range: [!NULL] \n
 *              Pointer to the buffer in which received message will be stored
 *
 * \param pDataLength - In & Out - Range: [!NULL] \n
 *              As input, it contains the size of buffer pData, as output it
 *              contains the size of the copied data in pData buffer. If the input
 *              size is smaller than the received message then only the beginning
 *              of the received message is copied into pData. The remaining of the
 *              received message is lost.
 *
 * \param timeout - In - Range: None \n
 *              Timeout of the wait on reception of message. If timeout is
 *              equal to 0, then the function does not wait. If no message
 *              is available then the function returns ALSTOM_C_TIMEOUT
 *              immediately.
 *
 *
 * \return ALSTOM_T_Status:
 *      - ALSTOM_C_NO_ERROR: entire message received successfully
 *      - ALSTOM_C_TOO_SMALL: message has been received, but the buffer was
 *                            too small, and the message has been truncated
 *      - ALSTOM_C_TIMEOUT: Reception timeout, no message received
 *      - ALSTOM_C_ERROR: Other reception error, no message received.
 *
 * \note This function waits for message by waiting message from the FIFO
 *       associated to the socket (cf. MSTEP_F_UDPOpen()). If this FIFO is also
 *       associated to other socket, then this function will not works
 *       correctly. In the same way, the FIFO must be dedicated to the
 *       reception of UDP messages, otherwise a FUSE will be burned (it is
 *       considered as a fault case). It means that if this function is used,
 *       the FIFO associated to the socket must be dedicated to this only
 *       socket.
 *
 ******************************************************************************/
ALSTOM_T_Status MSTEP_F_UDPRecv(const MSTEP_T_SocketID * pSocket, INT32U * pSrcAddr, INT16U * pSrcPort,
                                INT8U * pData, INT16U * pDataLength, INT16U timeout);

/**
 ******************************************************************************
 * \par Description:
 *      Flush a socket. The FIFO associated to the socket is emptied and
 *      messages are freed.
 *
 * \par Fault cases:
 *      - Parameter range error
 *
 * \par Pseudo-code:
 *      -# While FIFO not empty
 *        -# Get message from FIFO
 *        -# Free message
 *
 * \param pSocket - In - Range: [!NULL] \n
 *              Pointer to the socket which must be flushed.
 *
 *****************************************************************************/
void MSTEP_F_UDPFlush(const MSTEP_T_SocketID * pSocket);



/**
 ******************************************************************************
 * \par Description:
 *      This function sends data through an UDP socket.
 *      The message priority (2nd Most Significant Byte from destAddr) shall be
 *      equal to GUEST_C_LOW_PRIO or GUEST_C_HIGH_PRIO for destAddr on CAN interface.
 *
 *      Observation: Destination address on CAN interface can be built using the
 *      "IP_M_BUILD_IPOVERCAN" macro.
 *
 * \par Fault cases:
 *      - Parameters range error
 *
 * \param pSocket - In - Range: [!NULL] \n
 *              Socket through which data have to be send
 *
 * \param destAddr - In - Range: [!0] \n
 *              Destination IP address of the emission
 *
 * \param destPort - In - Range: none \n
 *              Destination UDP port of the emission
 *
 * \param pData - In - Range: [!NULL] \n
 *              Pointer to the data buffer to be send
 *
 * \param dataLength - In - Range: none \n
 *              Lenght of the buffer
 *
 *
 * \return ALSTOM_T_Status:\n
 *      - ALSTOM_C_NOT_RUNNING: IPSTACK is not started
 *      - ALSTOM_C_ERROR: Transmission error
 *      - ALSTOM_C_BAD_PARAMETER: Destination address equal to zero or
 *                                message priority different from
 *                                GUEST_C_LOW_PRIO and GUEST_C_HIGH_PRIO for
 *                                destAddr on CAN interface.
 *      - ALSTOM_C_NO_ERROR: no error
 *
 *****************************************************************************/
ALSTOM_T_Status MSTEP_F_UDPSend(const MSTEP_T_SocketID * pSocket, INT32U destAddr, INT16U destPort,
                                const INT8U * pData, INT16U dataLength);

#ifdef ALSTOM_CONFIG_CPU_B
/**
 ******************************************************************************
 * \par Description: This function is available on CPU B only and on board
 *      with A interface.
 *      (board mode equal to MSTEPINC_C_GUEST_INTA or MSTEPINC_C_STEPPER)
 *      Get the number of frame dropped and accepted by Redundancy layer
 *      ** NbRejected on Normal network
 *      ** NbAccepted on Normal network
 *      ** NbRejected on Redundant network
 *      ** NbAccepted on Redundant network
 *
 * \par Fault cases:
 *      - EVT_C_NULL_PTR_ERROR if pRedundancyStats is NULL pointer.
 *
 * \param pRedundancyStats - in out - range: [!NULL] \n
 *        Pointer on the redundancy layer statistics.
 *
 * \return void
 *
 * \note The 4 counters will be increased until it reaches the maximum integer
 *      value on 32 bits. Then there is a roundabout.
 *
 *****************************************************************************/
void MSTEP_F_StatRedIdGet(MSTEPINC_T_RedundancyStatistics *const pRedundancyStats);

/**
 ******************************************************************************
 * \par Description:
 *      This function is only available on CPU_B and on board with A interface.
 *      (board mode equal to MSTEPINC_C_GUEST_INTA or MSTEPINC_C_STEPPER)
 *      Get the maximum differential delay observed in redundancy layer (A13) between
 *      two redundant frames on the two network (normal and redunded).
 *
 * \par Fault cases:
 *      None
 *
 * \return INT32U - The maximum differential delay in milliseconds
 *
 *****************************************************************************/
INT32U MSTEP_F_StatRedIdMaxDiffDlyGet(void);

/**
 ******************************************************************************
 * \par Description:
 *      Get the maximum propagation delay observed on normal and redunded network.
 *      This function is only available on CPU_B and on a board with A interface.
 *      (board mode equal to MSTEPINC_C_GUEST_INTA or MSTEPINC_C_STEPPER)
 *
 *      The computation is performed only if the server NTP is considered as
 *      available \see MSTEP_F_MaintSNTPServerAvailability() on valid Identification
 *      layer frames (\see SyID_STEP_A1m).
 *
 *       - On a board without A interface (guest board for instance), the returned
 *         values will be equal to zero for both normal and redunded network.
 *       - The STANDBY board can see only one propagation time (NORMAL for
 *         PRIMARY STANDBY and REDUNDED for SECONDARY STANDBY). The other
 *         progation time will be set to zero.
 *       - On a board with A interface :
 *           - The STANDBY board can see only one propagation time
 *              (related to NORMAL link for PRIMARY BOARD and REDUNDED link for SECONDARY BOARD).
 *              The other propagation time will be set to zero.
 *           - The NORMAL board can see the two propagation times.
 *              Note that the value related to the link of the STANDBY board
 *              will be increased by the time required for the STANDBY routing.
 *              Therefore, the propagation time seen on the same network by both NORMAL and
 *              STANDBY board will be not equal.
 *
 *       Note that this function will return 0xFFFFFFFFu in the following cases:
 *          - The difference between the reception NTP date and the emission NTP date is superior
 *            than 0xFFFFFFFEu
 *          - The difference between the reception NTP date and the emission NTP date is negative
 *
 *       After, calling this function, both maximum are reseted.
 *
 * \par Fault cases:
 *      - Parameter range error
 *
 * \param  maxDly - Out - Range: [!NULL] \n
 *         Contain the returned propagation delays in milliseconds
 *
 * \return void
 *
 *****************************************************************************/
void MSTEP_F_StatRedIdMaxPropagationDlyGet(MSTEP_T_MaxRedIdPropagationDly * maxDly);

/**
 ******************************************************************************
 * \par Description:
 *      Get the maximum delta observed between two valid frame received
 *      on a redundancy session for normal and redunded network.
 *
 *      This function is only available on CPU_B and on a board with A interface.
 *      (board mode equal to MSTEPINC_C_GUEST_INTA or MSTEPINC_C_STEPPER)
 *       - On a board without A interface (guest board for instance), the returned
 *         values will be equal to zero for both normal and redunded network.
 *
 *      Note that sequence number is completely under control of the sender.
 *      We can't ensure a coherent result. In case, the shift computed between
 *      two frame is bigger than the max value of an INT32U, 0xffffffffu will be
 *      returned.
 *
 *      After, calling function, both maximum are reseted.
 *
 * \param  seqNb - Out - Range: [!NULL] \n
 *         Contain the maximum sequence number delta on each network
 *
 * \par Fault cases:
 *      - Parameter range error
 *
 * \return void
 *
 *****************************************************************************/
void MSTEP_F_StatRedIdMaxSequenceNbDeltaGet(MSTEP_T_MaxRedIdSequenceNb * seqNb);

#endif

/**
 ******************************************************************************
 * \par Description:
 *      Get the number of Ethernet frames with CRC OK which have been
 *      received. In GUEST NO ETH configuration this function always returns 0.
 *
 * \par Fault cases:
 *      None
 *
 * \return INT32U - Number of Ethernet CRC OK.
 *
 * \note The counter will be increased until it reaches the maximum integer
 *      value on 32 bits. Then there is a roundabout.
 *
 *****************************************************************************/
INT32U MSTEP_F_StatNbEthCrcOkGet(void);

/**
 ******************************************************************************
 * \par Description:
 *      Get the number of Ethernet frames with CRC error which have been
 *      received. In GUEST NO ETH configuration this function always returns 0.
 *
 * \par Fault cases:
 *      None
 *
 * \return INT32U - Number of Ethernet CRC error.
 *
 * \note The counter will be increased until it reaches the maximum integer
 *      value on 32 bits. Then there is a roundabout.
 *
 *****************************************************************************/
INT32U MSTEP_F_StatNbEthCrcErrorGet(void);

/**
 ******************************************************************************
 * \par Description:
 *      Get the number of Ip conflict detected since the board start-up
 *      or since the previous call of this function.
 *
 * \par Fault cases:
 *      None
 *
 * \return INT32U - Number of Ip conflict detected.
 *
 * \note
 *      The counter will be increased each time an Ethernet frame presenting an IP address conflict
 *       is received until until it reaches the maximum integer
 *      value on 32 bits.
 *
 *****************************************************************************/
INT32U MSTEP_F_StatNumberOfIpConflictDetectedGet(void);

/**
 ******************************************************************************
 * \par Description:
 *      Get the number of broken FSFB2 autonomous session.
 *      This function is only available on a board with A interface.
 *
 * \par Fault cases:
 *      None
 *
 * \return INT32U - The number of broken sessions
 *
 * \note The counter will be increased until it reaches the maximum integer
 *      value on 32 bits. Then there is a roundabout.
 *
 *****************************************************************************/
INT32U MSTEP_F_StatFSFB2NbBrokenSessionGet(void);

/**
 ******************************************************************************
 * \par Description:
 *      Get the  CPU usage rate
 * \par Fault cases:
 *      None
 *
 * \return INT32U - Range: [0..100] - CPU level in percentage.
 *
 * \note None
 *
 *****************************************************************************/
/*20200629, add app interface to provide CPU utilization, CR:2245*/

INT32U MSTEP_F_StatCPUUsageGet(void);

/**
 ******************************************************************************
 * \par Description:
 *      Get the maximal CPU usage rate which occurs since the board is in
 *      nominal mode (after initialization phase)
 *
 * \par Fault cases:
 *      None
 *
 * \return INT32U - Range: [0..100] - Max CPU level in percentage.
 *
 * \note None
 *
 *****************************************************************************/
INT32U MSTEP_F_StatCPUUsageMaxGet(void);

/**
 ******************************************************************************
 * \par Description:
 *      Get the number of times the Ethernet driver detect overflow, and so
 *      discard Ethernet messages.
 *      In GUEST NO ETH configuration this function always returns 0.
 *
 * \par Fault cases:
 *      None
 *
 * \return INT32U - Number of overflow detected by the driver.
 *
 * \note Overflow occurs when flood is detected on the link.
 *
 *****************************************************************************/
INT32U MSTEP_F_StatFecOverflowCountGet(void);

/**
 ******************************************************************************
 * \par Description:
 *      Get the number of received frame and frames to be transmitted which
 *      have been dropped (since boot) by the internal process of IPSTACK
 *      because traffic is too big and cannot be entirely managed by the
 *      kernel.
 *
 * \par Fault cases:
 *      - Parameter range error
 *
 * \param pRxDrop - Out - Range: [!NULL] \n
 *              Pointer to the number of rx frame which have been dropped.
 *
 * \param pTxDrop - Out - Range: [!NULL] \n
 *              Pointer to the number of tx frame which have been dropped.
 *
 *****************************************************************************/
void MSTEP_F_StatIpstackInternalFrameDropGet(INT32U * pRxDrop, INT32U * pTxDrop);


/**
 ******************************************************************************
 * \par Description:
 *      This function return a scrambled value depending on which 16 higher or
 *      16 lower bits have to be scrambled.
 *
 * \par Limitations:
 *      if a re-programmation request is authorized by application guest,
 *      then the system check word used by this function is modified.
 *
 * Value returned is computed as follow:
 *      if part = LSB
 *         for the 16 LSB, Y = X (16 LSB)  XOR CRC16(SystemCheckWord)
 *         for the 16 MSB, Y = X (16 MSB)
 *      if part = MSB
 *          for the 16 LSB, Y = X (16 LSB)
 *          for the 16 MSB, Y = X (16 MSB) XOR CRC16(SystemCheckWord)
 *
 * \par Fault cases:
 *      None
 *
 * \param  key - In - Range: none \n
 *         Value to scramble
 *
 * \param  part - In - Range: [MSTEP_C_SCRAMBLE_LSB..MSTEP_C_SCRAMBLE_MSB] \n
 *         Part on which the scrambling have to be done
 *
 * \if SwMD
 * \par Safety Aspects:
 * - None
 * \endif
 *
 * \return INT32U -
 *         - Value scrambled according  to the algorithm above.
 *
 *****************************************************************************/
/** CR reference 2740 - API MSTEP_F_CryptlibKeyScramble usage restriction */
INT32U MSTEP_F_CryptlibKeyScramble(INT32U key, MSTEP_E_ScramblePart part);

#ifdef ALSTOM_CONFIG_CPU_A
/**
 *****************************************************************************
 * \par Description:
 *      This function returns current configuration key status. This status
 *      is updated on kernel side once at start-up, then every 30 seconds
 *      during cyclic key check.
 *      This function is only available on CPU_A.
 *
 * \par Fault cases:
 *      None
 *
 * \return MSTEPINC_E_ConfKeyStatus
 *      Configuration key status, as per last kernel update
 *
 * \note This function is available on CPU A only
 *
 *****************************************************************************/
MSTEPINC_E_ConfKeyStatus MSTEP_F_MaintConfKeyStatusGet(void);
#endif

/**
 *****************************************************************************
 * \par Description:
 *      This function returns current alpha and beta CAN bus status.
 *
 * \par Fault cases:
 *      EVT_C_NULL_PTR_ERROR in case of null pointer as parameter
 *
 * \param pNormalBusStatus - Out - Range: [!NULL] \n
 *      Used to return normal bus status: OK or OUT_OF_ORDER
 * \param pRedundantBusStatus - Out - Range: [!NULL] \n
 *      Used to return redundant bus status: OK or OUT_OF_ORDER
 *
 * \return void
 *
 *****************************************************************************/
void MSTEP_F_MaintCanBusStatusGet(MSTEPINC_E_CanBusStatus * pNormalBusStatus, MSTEPINC_E_CanBusStatus * pRedundantBusStatus);

/**
 *****************************************************************************
 * \par Description:
 *      This function returns hardware, software and configuration packet
 *      data versions, as stored either in GUEST electronic stamp or in
 *      configuration key module header.
 *
 * \par Fault cases:
 *      EVT_C_NULL_PTR_ERROR in case of null pointer as parameter
 *
 * \param pHwVersion - Out - Range: [!NULL] \n
 *      Used to return a pointer on first character of hardware version string
 * \param pSwVersion - Out - Range: [!NULL] \n
 *      Used to return a pointer on first character of software version string
 * \param pDataVersion - Out - Range: [!NULL] \n
 *      Used to return a pointer on first character of data version string
 *
 * \return  void
 *
 * \par Pseudo-code:
 *      -# Retrieve pointers to HW and SW versions
 *      -# Retrieve pointer to DATA version
 *
 * \note pHwVersion and pSwVersion have 15 meaningful characters and
 *       pDataVersion has 5 meaningful characters.
 *
 *****************************************************************************/
void MSTEP_F_MaintVersionsGet(CHAR ** pHwVersion, CHAR ** pSwVersion, CHAR ** pDataVersion);

/**
 *****************************************************************************
 * \par Description:
 *      This function, available on STEPPER board only, returns the states of
 *      the SNTP server connection.
 *
 *      The server is considered as:
 *      - available if we receive a valid SNTP answer.
 *      - unavailable if we send 3 requests without answer.
 *
 * \par Fault cases:
 *      None
 *
 * \return BOOLEAN
 *            - TRUE if SNTP service available.
 *            - FALSE, otherwise.
 *
 *****************************************************************************/
BOOLEAN MSTEP_F_MaintSNTPServerAvailability(void);

/**
 ******************************************************************************
 * \par Description:
 *      This function notify to the kernel that the calling task has finished
 *      its transition from Normal to Restrictive functional mode. If the field
 *      bNotifyRestrictiveOk of structure MSTEPINC_T_TaskInfo of the task has
 *      been set to true, then this function has to be called, otherwise, it is
 *      useless.
 *
 * \par Fault cases:
 *      - Unknown guets task ID.
 *
 * \see MSTEPINC_T_TaskInfo
 *****************************************************************************/
/* Implements <STEP_SwAD_1143> */
void MSTEP_F_NotifyEndOfRestrictiveTransition(void);


/**
 ******************************************************************************
 * \par Description:
 *      Add notification flag to IODB merge event. IODB will post flags in
 *      flag group after the merge. The merge period is between 40 and 60 ms.
 *      So the recommended timeout for the pend on the notification flag is at
 *      least 65 ms.
 *
 * \par Fault cases:
 *      - Parameter range error
 *
 * \param pGrp - In - Range: [!NULL] \n
 *              Flag group to be used for notification
 *
 * \param flags - In - Range: [!=0] \n
 *              Flags to be posted in the flag group.
 *
 * \param action - In - Range: None \n
 *              Post flag action.
 *
 * \param bCheckUsage - In - Range: None \n
 *              If TRUE, then IODB will check that the previous notification
 *              has been used before realizing a new notification. If FALSE,
 *              then it is not verified. A notification is considered as used
 *              if:
 *                - action is equal to OSW_C_FLAG_CLR and all the given flags
 *                  are set
 *                - action is equal to OSW_C_FLAG_SET and all the given flags
 *                  are cleared
 *
 * \note
 *      For a basic notification usage, it is recommended to call this function
 *      during the 'Start' function of a non periodic task with parameter
 *      bCheckUsage equal to TRUE
 *****************************************************************************/
void MSTEP_F_IodbNotificationAdd(OSW_T_pFLAG_GRP *pGrp,
                                 OSW_T_FLAGS flags,
                                 OSW_T_FLAG_ACT action,
                                 BOOLEAN bCheckUsage);

#ifdef ALSTOM_CONFIG_CPU_B
/* CR_reference 847 - Robustification of the management of delayed BSD */
/**
 ******************************************************************************
 * \par Description:
 *      Activate Incremental algorithm for USIG redundancy layer. This function is
 *      only defined on CPU_B. This function shall be called
 *      by function GUEST_F_SystemSetup() only.
 *
 * \par Fault cases:
 *      - Parameter out of range
 *
 * \param threashold - In - Range: [ < 0xFFFFFFFF/1000] \n
 *              Time threshold (in seconds) of Incremental algorithm
 *
 * \param lProtect - In - Range: None \n
 *              LProtect value of Incremental algorithm
 *
 *****************************************************************************/
/* Implements <STEP_SyID_A13_0047> */
/* Implements <STEP_SwAD_1097> */
void MSTEP_F_SettingsUsigRedIncrAlgoActivate(INT32U threashold, INT32U lProtect);
#endif

/**
 ******************************************************************************
 * \par Description:
 *      This function subscribes a TFTP service. A service subscribed can never
 *      be unsubscribed. At max, MSTEP_C_TFTP_MAX_GUEST_TFTP_SERVICE services
 *      can be subscribed.
 *      To be subscribed, a service gives :
 *         - 3 letters used to identify the service. Each file name used shall
 *           begins with theses 3 letters.
 *         - A function pointer to open a file via this service
 *         - A function pointer to close a file via this service.
 *
 * \par Fault cases:
 *      - serviceName is NULL
 *      - Too many TFTP services subscribed
 *
 * \param serviceName - In - Range: [!null] \n
 *      Service name (have to be 3 letters long)
 * \param openFunc    - In - Range: none \n
 *      Function pointer called when a new TFTP file transfer request is
 *      received for the service. \see MSTEP_T_TftpOpenConnectionCB for more
 *      details.
 * \param closeFunc   - In - Range: none \n
 *      Function pointer called when a TFTP file transfer associated to the
 *      service is finished. If no particular function have to be realized, this
 *      parameter can be set to NULL. \see MSTEP_T_TftpCloseConnectionCB for
 *      more details.
 *
 * \return - ALSTOM_C_NO_ERROR if service is successfully subscribed
 *         - (ALSTOM_T_Status)TFTP_C_ERROR_NO_FREE_SERVICE if no free service are available
 *****************************************************************************/
/* Implements <STEP_SwAD_1096> */
ALSTOM_T_Status MSTEP_F_TftpServiceSubscribe(const CHAR * const serviceName, MSTEP_T_TftpOpenConnectionCB openFunc,
                                             MSTEP_T_TftpCloseConnectionCB closeFunc);

/*20210803,delete APIs realted to read parameters, CR:2929*/

/**
 ******************************************************************************
 * \par Description:
 *      This function provide access to a statistic array which store for
 *      all tasks the minimum remaining watchdog cycle before entering
 *      SAFE_STATE.
 *
 *      How to use it :
 *
 *      To have the minimum remaining watchdog cycle for a task, user shall
 *      provide as index the TaskPrio of the wanted task.
 *
 * \par Fault cases:
 *      - Parameter range error
 *      - EVT_C_NULL_PTR_ERROR if pPeriodTableMin or pMaxSize is NULL.
 *
 * \param pPeriodTableMin - out - Range: [!NULL]\n
 *        Pointer to statistic array of minimum remaining watchdog cycle
 *        of all tasks.
 *
 * \param pMaxSize - out - Range: [!NULL]\n
 *        Pointer to the size of the pPeriodTableMin array.
 *        Make sure to check range before using pPeriodTableMin
 *
 * \return :
 *  - None
 *
 *****************************************************************************/
void  MSTEP_F_PeriodTableMinGet(INT16U** pPeriodTableMin, INT8U* pMaxSize);

/*****************************************************************************/
/**
* \par Description:  get the compensated safety flag value
*
* \par Fault cases:
*        - Parameter range error
*
* \param safetyFlagNum - In - Range: [GUEST_C_MIN_SAFETY_FLAG..GUEST_C_MAX_SAFETY_FLAG] \n
*          index of the compensated safety flag value to get
*
* \return INT32U
*          compensated value of the safety flag
*
******************************************************************************/
/* Implements <STEP_SwAD_1269> */
INT32U MSTEP_F_SafetyFlagChkWdGet(INT32U safetyFlagNum);

/*****************************************************************************/
/**
* \par Description:  break the specified safety flag
*
* \par Fault cases:
*        - Parameter range error
*
* \param safetyFlagNum - In - Range: [GUEST_C_MIN_SAFETY_FLAG..GUEST_C_MAX_SAFETY_FLAG] \n
*          index of the safety flag to break
*
* \param pNotif - In - Range: None \n
*              notification to perform when the safety flag has been successfully broken.
*              If NULL, no notification is realized.
*
* \par limitations:
*              a) Make sure that this function is always called in a higher
*              priority task context than BIST one. If not, some unexpected behavior
*              can occurs (including Kernel Fuse).
*              b) This function shall not be called multiple times in a row
*              in order to break all the safety flags (CR2411).
*
* \return void
*
******************************************************************************/
/* Implements <STEP_SwAD_1269> */
void MSTEP_F_SafetyFlagBreak(INT32U safetyFlagNum, BIST_T_FuseInFlashFlagNotifInfo * pNotif);


/*****************************************************************************/
/**
* \par Description:  Get software data identifier of the code (XOR of each reference CRC)
*
* \par Fault cases:
*        - None

* \return INT32U global identifier
*
******************************************************************************/
/* Implements <STEP_SwAD_1294> */
INT32U MSTEP_F_GetSoftwareDataID(void);

/* CR_reference 2024 - triggered functions */
/*****************************************************************************/
/**
* \par Description:  register a triggered function to vivisection
*
* \par Fault cases:
*        - EVT_C_NULL_PTR_ERROR if pDataArray is NULL and receptionBufferLength is != 0
*        - EVT_C_NULL_PTR_ERROR if triggeredFunction is NULL
*        - Parameter range error
*
* \param uniqueID - In - Range: !0\n
*          unique identifier of the triggered function
* \param triggeredFunction - In - Range: !NULL\n
*          unique identifier of the triggered function
* \param pReceptionBuffer - In - Range: !NULL if receptionBufferLength != 0\n
*          array where the received data will be stored
* \param receptionBufferLength - In - Range: [0..MSTEPINC_C_MAX_TRIGGERED_DATA] \n
*          expected length of the data received from vivisection trigger command
*
* \return ALSTOM_T_Status
*          ALSTOM_C_NO_ERROR if the function is registered
*          ALSTOM_C_ERROR if all triggered function slots are taken or the ID is already used
*
******************************************************************************/
/* Implements <STEP_SwAD_1539> */
ALSTOM_T_Status MSTEP_F_RegisterTriggeredFunction(INT32U uniqueID, MSTEPINC_T_TriggeredFunction triggeredFunction,
                                                  INT8U *pReceptionBuffer, INT8U receptionBufferLength);

/* CR_reference 1486 - Fault filtering feature */
/*****************************************************************************/
/**
* \par Description: Give information about the last reboot.
*
*
* \par Fault cases:
*        - None

* \return BOOLEAN
*         TRUE : means than the board has reboot following a safety failure
*         This is only possible when the application allowed the fault
*         filtering mechanism
*
*         False : classic boot.
*
******************************************************************************/
/* Implements <STEP_SwAD_1400> */
BOOLEAN MSTEP_F_FaultFilteringStateGet(void);

/* Implements <STEP_SwAD_1650> */
/*****************************************************************************/
/**
* \par Description:
*      This function returns the number of reboot due to fault filtering.
*
* \par Fault cases:
*      None
*
* \return INT32U - number of reboot due to fault filtering
*
*****************************************************************************/
INT32U MSTEP_F_NbFaultFilteringRebootGet(void);

/* Implements <STEP_SwAD_1440> */
/*****************************************************************************/
/**
* \par Description:
*      This function clear maintenance default permanently (even after reboot).
*      Note: The DUMP is not longer retrievable once this operation is performed.
*
* \par Fault cases:
*        - None
*
* \return
*      - Nothing
*
******************************************************************************/
void MSTEP_F_FaultFilteringAcknowledge(void);

/* CR_reference 2022 - Statistics features */
/*****************************************************************************/
/**
* \par Description:  Initializes a statistic storage with the provided records
* buffer.
* The array will store the various records.
*
* \par Fault cases:
*        - EVT_C_NULL_PTR_ERROR
*        - Parameter range error
*
* \param pStatStorage - In/Out - Range: != NULL \n
*          pointer to the STAT_T_StatStorage to initialize
* \param pStatRecordsArray - In - Range: != NULL \n
*          pointer to the STAT_T_StatRecord array to use to store statistic records
* \param maxNbRecords - In - Range: [1..0xFF] \n
*          max number of records to store in the STAT_T_StatRecord array
*
******************************************************************************/
void MSTEP_F_StatInit(STAT_T_StatStorage *pStatStorage, STAT_T_StatRecord *pStatRecordsArray, INT8U maxNbRecords);

/* CR_reference 2022 - Statistics features */
/*****************************************************************************/
/**
* \par Description:  Enable a statistic storage to store records.
* If the function to store a value is called with the storage not enabled, the
* value is not stored.
*
* \par Fault cases:
*        - EVT_C_NULL_PTR_ERROR
*
* \param pStatStorage - In/Out - Range: != NULL \n
*          pointer to the STAT_T_StatStorage to enable
*
* \return - ALSTOM_C_NO_ERROR if success
*         - ALSTOM_C_ERROR if the statistic is already enabled
*
******************************************************************************/
ALSTOM_T_Status MSTEP_F_StatEnable(STAT_T_StatStorage *pStatStorage);

/* CR_reference 2022 - Statistics features */
/*****************************************************************************/
/**
* \par Description:  Check if a statistic is enabled.
*
* \par Fault cases:
*        - EVT_C_NULL_PTR_ERROR
*
* \param pStatStorage - In - Range: != NULL \n
*          pointer to the STAT_T_StatStorage to check
*
* \return - TRUE if enabled
*         - FALSE if not
*
******************************************************************************/
BOOLEAN MSTEP_F_StatIsEnabled(const STAT_T_StatStorage *pStatStorage);

/* CR_reference 2022 - Statistics features */
/*****************************************************************************/
/**
* \par Description:  Disable a statistic storage to store records.
* If the function to store a value is called with the storage not enabled, the
* value is not stored.
*
* \par Fault cases:
*        - EVT_C_NULL_PTR_ERROR
*
* \param pStatStorage - In/Out - Range: != NULL \n
*          pointer to the STAT_T_StatStorage to disable
*
* \return - ALSTOM_C_NO_ERROR if success
*         - ALSTOM_C_ERROR if the statistic is already disabled
*
******************************************************************************/
ALSTOM_T_Status MSTEP_F_StatDisable(STAT_T_StatStorage *pStatStorage);

/* CR_reference 2022 - Statistics features */
/*****************************************************************************/
/**
* \par Description:  Reset the fields of the statistic storage.
*
* \par Fault cases:
*        - EVT_C_NULL_PTR_ERROR
*
* \param pStatStorage - In/Out - Range: != NULL \n
*          pointer to the STAT_T_StatStorage to reset
*
* \return - ALSTOM_C_NO_ERROR if success
*         - ALSTOM_C_ERROR if the statistic is enabled
*
******************************************************************************/
ALSTOM_T_Status MSTEP_F_StatReset(STAT_T_StatStorage *pStatStorage);

/* CR_reference 2022 - Statistics features */
/*****************************************************************************/
/**
* \par Description:  Store an INT32U value in the statistic storage.
* The time of the recording is stored. The global min/max values are calculated.
* The global sum of the values is calculated. The total number of values processed
* is stored.
*
* \par Fault cases:
*        - EVT_C_NULL_PTR_ERROR
*
* \param pStatStorage - In/Out - Range: != NULL \n
*          pointer to the STAT_T_StatStorage where to store the value
* \param value - In - Range: None \n
*          INT32U value to store
*
* \return - ALSTOM_C_NO_ERROR if success
*         - ALSTOM_C_ERROR if the statistic is not enabled or if the
*           globalSumValue overflows
*
******************************************************************************/
ALSTOM_T_Status MSTEP_F_StatStoreValue(STAT_T_StatStorage *pStatStorage, INT32U value);

/* CR_reference 2022 - Statistics features */
/*****************************************************************************/
/**
* \par Description:  Get the global minimum INT32U value recorded.
*
* \par Fault cases:
*        - EVT_C_NULL_PTR_ERROR
*
* \param pStatStorage - In - Range: != NULL \n
*          pointer to the STAT_T_StatStorage of the statistic
* \param pMinValue - Out - Range: != NULL \n
*          pointer to the resulting value
*
* \return - ALSTOM_C_NO_ERROR if success
*         - ALSTOM_C_ERROR if no recorded value found
*
******************************************************************************/
ALSTOM_T_Status MSTEP_F_StatGetGlobalMinValue(const STAT_T_StatStorage *pStatStorage, INT32U *pMinValue);

/* CR_reference 2022 - Statistics features */
/*****************************************************************************/
/**
* \par Description:  Get the global maximum INT32U value recorded.
*
* \par Fault cases:
*        - EVT_C_NULL_PTR_ERROR
*
* \param pStatStorage - In - Range: != NULL \n
*          pointer to the STAT_T_StatStorage of the statistic
* \param pMaxValue - Out - Range: != NULL \n
*          pointer to the resulting value
*
* \return - ALSTOM_C_NO_ERROR if success
*         - ALSTOM_C_ERROR if no recorded value found
*
******************************************************************************/
ALSTOM_T_Status MSTEP_F_StatGetGlobalMaxValue(const STAT_T_StatStorage *pStatStorage, INT32U *pMaxValue);

/* CR_reference 2022 - Statistics features */
/*****************************************************************************/
/**
* \par Description:  Get the total number of recorded values.
*
* \par Fault cases:
*        - EVT_C_NULL_PTR_ERROR
*
* \param pStatStorage - In - Range: != NULL \n
*          pointer to the STAT_T_StatStorage of the statistic
* \param pNbValues - Out - Range: != NULL \n
*          pointer to the resulting number
*
******************************************************************************/
void MSTEP_F_StatGetGlobalNbValues(const STAT_T_StatStorage *pStatStorage, INT32U *pNbValues);

/* CR_reference 2022 - Statistics features */
/*****************************************************************************/
/**
* \par Description:  Get the global sum of recorded values.
*
* \par Fault cases:
*        - EVT_C_NULL_PTR_ERROR
*
* \param pStatStorage - In - Range: != NULL \n
*          pointer to the STAT_T_StatStorage of the statistic
* \param pSumValue - Out - Range: != NULL \n
*          pointer to the resulting value
*
* \return - ALSTOM_C_NO_ERROR if success
*         - ALSTOM_C_ERROR if no recorded value found
*
******************************************************************************/
ALSTOM_T_Status MSTEP_F_StatGetGlobalSumValue(const STAT_T_StatStorage *pStatStorage, INT32U *pSumValue);

/* CR_reference 2022 - Statistics features */
/*****************************************************************************/
/**
* \par Description:  Get the global average INT32U value recorded. In case of
* global sum overflow, it is calculated using correct number of recorded values.
*
* \par Fault cases:
*        - EVT_C_NULL_PTR_ERROR
*
* \param pStatStorage - In - Range: != NULL \n
*          pointer to the STAT_T_StatStorage of the statistic
* \param pAverageValue - Out - Range: != NULL \n
*          pointer to the resulting value
*
* \return - ALSTOM_C_NO_ERROR if success
*         - ALSTOM_C_ERROR if no recorded value found
*
******************************************************************************/
ALSTOM_T_Status MSTEP_F_StatGetGlobalAverageValue(const STAT_T_StatStorage *pStatStorage, INT32U *pAverageValue);

/* CR_reference 2022 - Statistics features */
/*****************************************************************************/
/**
* \par Description:  Get the minimum INT32U value currently recorded in the
* circular buffer.
*
* \par Fault cases:
*        - EVT_C_NULL_PTR_ERROR
*
* \param pStatStorage - In - Range: != NULL \n
*          pointer to the STAT_T_StatStorage of the statistic
* \param pMinValue - Out - Range: != NULL \n
*          pointer to the resulting value
*
* \return - ALSTOM_C_NO_ERROR if success
*         - ALSTOM_C_ERROR if no recorded value found
*
******************************************************************************/
ALSTOM_T_Status MSTEP_F_StatGetMinValueFromRecords(const STAT_T_StatStorage *pStatStorage, INT32U *pMinValue);

/* CR_reference 2022 - Statistics features */
/*****************************************************************************/
/**
* \par Description:  Get the maximum INT32U value currently recorded in the
* circular buffer.
*
* \par Fault cases:
*        - EVT_C_NULL_PTR_ERROR
*
* \param pStatStorage - In - Range: != NULL \n
*          pointer to the STAT_T_StatStorage of the statistic
* \param pMaxValue - Out - Range: != NULL \n
*          pointer to the resulting value
*
* \return - ALSTOM_C_NO_ERROR if success
*         - ALSTOM_C_ERROR if no recorded value found
*
******************************************************************************/
ALSTOM_T_Status MSTEP_F_StatGetMaxValueFromRecords(const STAT_T_StatStorage *pStatStorage, INT32U *pMaxValue);

/* CR_reference 2022 - Statistics features */
/*****************************************************************************/
/**
* \par Description:  Get the average INT32U value currently recorded in the
* circular buffer. In case of sum overflow, it is calculated using correct
* number of recorded values.
*
* \par Fault cases:
*        - EVT_C_NULL_PTR_ERROR
*
* \param pStatStorage - In - Range: != NULL \n
*          pointer to the STAT_T_StatStorage of the statistic
* \param pAverageValue - Out - Range: != NULL \n
*          pointer to the resulting value
*
* \return - ALSTOM_C_NO_ERROR if success
*         - ALSTOM_C_ERROR if no value has been recorded yet or if a local
*           sums overflows
*
******************************************************************************/
ALSTOM_T_Status MSTEP_F_StatGetAverageValueFromRecords(const STAT_T_StatStorage *pStatStorage, INT32U *pAverageValue);

/** Stopwatch functions */
/* CR_reference 2022 - Statistics features */
/*****************************************************************************/
/**
* \par Description:  Reset the provided stopwatch structure.
*
* \par Fault cases:
*        - EVT_C_NULL_PTR_ERROR
*
* \param pStopwatch - In - Range: != NULL \n
*          pointer to the STAT_T_Stopwatch structure
*
******************************************************************************/
void MSTEP_F_StatResetStopwatch(STAT_T_Stopwatch *pStopwatch);

/* CR_reference 2022 - Statistics features */
/*****************************************************************************/
/**
* \par Description:  Start/Restart a stopwatch. The previous elapsed time is
* kept.
*
* \par Fault cases:
*        - EVT_C_NULL_PTR_ERROR
*
* \param pStopwatch - In - Range: != NULL \n
*          pointer to the STAT_T_Stopwatch structure
*
* \return - ALSTOM_C_NO_ERROR if success
*         - ALSTOM_C_ERROR if the stopwatch is already running
*
******************************************************************************/
ALSTOM_T_Status MSTEP_F_StatStartStopwatch(STAT_T_Stopwatch *pStopwatch);

/* CR_reference 2022 - Statistics features */
/*****************************************************************************/
/**
* \par Description:  Stop a stopwatch. The elapsed time is added to the previous
* elapsed time.
*
* \par Fault cases:
*        - EVT_C_NULL_PTR_ERROR
*
* \param pStopwatch - In - Range: != NULL \n
*          pointer to the STAT_T_Stopwatch structure
*
* \return - ALSTOM_C_NO_ERROR if success
*         - ALSTOM_C_ERROR if the stopwatch is already stopped
*
******************************************************************************/
ALSTOM_T_Status MSTEP_F_StatStopStopwatch(STAT_T_Stopwatch *pStopwatch);

/* CR_reference 2022 - Statistics features */
/*****************************************************************************/
/**
* \par Description:  Get the total elapsed time since the first start. The time
* elapsed while the stopwatch is stopped is not counted.
*
* \par Fault cases:
*        - EVT_C_NULL_PTR_ERROR
*
* \param pStopwatch - In - Range: != NULL \n
*          pointer to the STAT_T_Stopwatch structure
* \param pElapsedTime - Out - Range: != NULL \n
*          pointer to the resulting timestamp
*
* \return - current state (running or stopped) of the stopwatch
*
******************************************************************************/
STAT_E_StopwatchState MSTEP_F_StatStopwatchElapsedTime(const STAT_T_Stopwatch *pStopwatch, STAT_T_Timestamp *pElapsedTime);

/* CR_reference 1760 - CommonTime synchronization. */
/**
 ******************************************************************************
 * \par Description:
 *      Returns the status (TRUE/FALSE) of the CommonTime synchronization
 *      between both CPUs.
 *      Observation: TRUE also means that the flashing functionality
 *      (if activated) has started.
 *
 * \par Fault cases:
 *      None
 *
 * \return BOOLEAN - TRUE, if the CommonTime is synchronized between both CPUs.
 *                   FALSE, otherwise.
 *
 *****************************************************************************/
BOOLEAN MSTEP_F_IsCommonTimeSynchronized(void);


/**
 ******************************************************************************
 * \par Description:
 *      Get the pointer to the STAT_T_StatStorage variable which store
 *      the time remaining (in ms) before k2oo2 timeout fuse
 *      (K2OO2_F_RepeatDataFrame).
 *
 *      Once this pointer has been retrieved user can use all the STAT function
 *      to get informations like min value, max value, global average, local average
 *      ...
 *
 * \par Fault cases:
 *      - NULL pointer
 *
 * \param pStatStorage - In/Out - Range: [!NULL] \n
 *              pointer to the STAT_T_StatStorage k2oo2 timeout statistic.
 *
 *****************************************************************************/
/* CR_Reference 2275 : k2oo2 timeout statistic */
/* Implements <STEP_SwAD_1653> */
void MSTEP_F_K2oo2StatGet(const STAT_T_StatStorage ** pStatStorage);

void MSTEP_F_TFTPClientWrite(INT32U destAddr, CHAR* serveName, INT8U* data, INT32U maxLength, OSW_T_pFLAG_GRP pFlagGrp, INT32U flags, INT8U* pErr);
INT8U MSTEP_F_SyncCurNumGet(void);

/**
 ******************************************************************************
 * \par Description:
 *      Get PDO restrict status after read PDO by SDB_F_DataIdRequest() and PDO is restrict value.
 *
 * \return BOOLEAN:
 *         - TRUE if any PDO in the board reach forgive time and set to restrict
 *         - FALSE else.
 *add API to get PDO restrict status, CR:2929
 *****************************************************************************/
BOOLEAN MSTEP_F_PDORestrictStatusGet(void);

/**\}*/ /*End of MSTEP_INTERFACE*/

#endif /* MSTEP_H */

/* EOF */
